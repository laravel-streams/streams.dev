[{"id":"api","stage":"review","title":"API Readiness","category":"core_concepts","enabled":true,"publish_at":null,"sort":10,"body":"Introduction\nThe Streams platform provides an optional two-way universal RESTful API and Javascript client. The API provides access and management control to all domain information and models and a streamlined interface to define custom endpoints.\n\n\nIntroduction\n\n\nEndpoints\n\n\nClient\n\n\n","href":"\/docs\/api"},{"id":"configuration","title":"Configuration","category":"getting_started","stage":"review","enabled":true,"sort":2,"body":"Introduction\nStreams uses Laravel config files and environment variables for application-level settings.\nConfiguration Files\nPublished configuration files reside in config\/streams\/.\n\u251c\u2500\u2500 config\/streams\/\n\u2502   \u251c\u2500\u2500 core.php\n\u2502   \u251c\u2500\u2500 api.php\n\u2502   \u2514\u2500\u2500 ui.php\n\nPublishing Configuration\nUse the following command to publish configuration files.\nphp artisan vendor:publish --tag=config\n\nTo publish configuration for a specific package use the following:\nphp artisan vendor:publish --provider=Streams\\\\Core\\\\StreamsServiceProvider --tag=config\n\nThe above commands will copy configuration files from their package location to the directory mentioned above so that you can modify them directly and commit them to your version control system.\nEnvironment Variables\nIt is often helpful to have different configuration values based on the environment in which your application is running. For example, you may wish to enable &quot;debug mode&quot; on your local server but not your production server.\nThe .env File\nEnvironmental variables are defined in the .env file in your project's root directory. In fresh installations, Composer will automatically rename the included .env.example file to .env for you.\nYou can manually copy and rename, or use php -r &quot;copy('.env.example', '.env');&quot; if the file does not already exist.\nEnvironment Variable Types\nVariables in your .env files parse as strings. A couple specific values are worth noting:\nEXAMPLE_VAR=        # (string) ''\nEXAMPLE_VAR=null    # (null) null\n\nIf you need to define an environment variable value containing a space, you may enclose the value in double-quotes.\nAPP_NAME=&quot;Spaghetti + Meatballs&quot;\n\nRetrieving Environment Variables\nAll environmental variables are available in configuration files by using the env() helper function. An optional second argument allows you to pass a default value.\n\/\/ config\/app.php\n'debug' =&gt; env('APP_DEBUG', false),\n\nOnce passed into a config file, the variable is available using the config() helper function. Again, an optional second argument allows you to specify a default value.\n\/\/ Retrieve the above 'debug' value:\nconfig('app.debug', false)\n\nDo not version your .env file\nThe .env file should not be committed to version control. Each developer or server running your application may require a different environment configuration. It is also a security risk if a nefarious character gains access to your version control repository because sensitive data like credentials, API keys, and other configuration would be visible to them.\nHiding Environment Variables from Debug Pages\nWhen an exception is uncaught, and the APP_DEBUG environment variable is true, the debug page will show all environment variables and their assigned values. You may obscure variables by updating the debug_blacklist option in your config\/app.php file.\nreturn [\n\n    \/\/ ...\n\n    'debug_blacklist' =&gt; [\n        '_ENV' =&gt; [\n            'APP_KEY',\n            'SECRET_API_KEY',\n            'BITCOIN_WALLET_PW',\n        ],\n\n        '_SERVER' =&gt; [\n            'APP_KEY',\n            'DB_PASSWORD',\n        ],\n\n        '_POST' =&gt; [\n            'password',\n        ],\n    ],\n];\n\nLearn more about environment configuration in the Laravel docs.\n","href":"\/docs\/configuration"},{"id":"contributing","title":"Contributing","category":"getting_started","stage":"review","enabled":true,"sort":30,"references":["https:\/\/laravel.com\/docs\/7.x\/contributions","https:\/\/craftcms.com\/docs\/3.x\/coc.html"],"body":"Contribution Guide\nThank you for considering contributing to the Streams platform! Please review the entire guide before submitting a bug report or pull request.\nBug Reports\nWe very much encourage pull requests, not just bug reports.\nA &quot;Bug Report&quot; should contain a title and a clear, detailed description of the issue. You should also include as much relevant information as possible and a code sample that demonstrates the problem. Bug reports intend to make it easy for yourself and others to replicate the bug and develop a fix.\nRemember, bug reports intend to promote collaboration with others experiencing the same problem to fix the bug in question. Do not expect that the bug report will automatically see any activity or that others will jump to fix it. Creating a bug report serves to help yourself and others start on the path of fixing the problem.\nWhich Repository?\nPlease send all issues to the streams\/streams repository to help us keep them consolidated.\nSend all pull requests to the respective repository they apply to and the branch as described below.\nWhich Branch?\nKindly send all bug fixes to the latest stable branch. Bug fixes should never be sent to development branches unless they fix issues found exclusively in the upcoming release.\nSend all minor features that are fully backward compatible with the current release to the latest stable branch.\nSend all significant new features to the development branch, which contains the upcoming Streams release.\nIf you are unsure if your feature qualifies as a major or minor, please ask Ryan Thompson in the #general Discord channel.\nSecurity Vulnerabilities\nIf you discover a security vulnerability within our project, please send an e-mail to Ryan Thompson at security@streams.dev for prompt handling.\nCoding Style\nThe Streams platform follows the PSR-4, PSR-2, and PSR-1 coding standards.\n","href":"\/docs\/contributing"},{"id":"core","title":"Laravel Development","category":"core_concepts","stage":"drafting","enabled":true,"sort":2,"body":"Introduction\nEnhancing Laravel is a fundamental aspect of Streams Core. Laravel enhancement facilitates internal core functionality and supports developers when building their work.\n\nCLI Tooling Documentation\n\nLaravel Basics\nStreams Core helps you take Laravel basics further and in less time.\n\n\nViews\n\n\nRouting\n\n\nCaching\n\n\nUtilities\n\n\nSecurity\n\n\nFrontend Support\nStreams Core provides frontend support that encourages and supports best-practices.\n\n\nAssets\n\n\nImages\n\n\nApplication Support\nSupport for building powerful and versatile Laravel products and services.\n\n\n\nAddons\n\n\nExtensibility\n\n\nMulti-Tenancy\n\n\n","href":"\/docs\/core"},{"id":"examples","sort":99,"title":"Examples","category":"getting_started","stage":"review","enabled":true,"body":"Dig into working projects to learn more about how Laravel Streams can be used.\nStarter Project\nA new Laravel Streams project, ready to go.\n\n\nStarter Project\n\n\nTodos App\nA simple todos application with a decoupled backend using the Streams API and the API Client.\n\n\nTodos Backend\n\n\nTodos Frontend (Vue)\n\n\nTodos Frontend (React)\n\n\n","href":"\/docs\/examples"},{"id":"installation","sort":1,"title":"Installation","category":"getting_started","stage":"review","enabled":true,"body":"Server Requirements\nTo run Laravel Streams you will need to meet Laravel server requirements.\nSupported Image Libraries\nPlease ensure one of the following libraries is installed in order to support image manipulation.\n\nGD Library\nImagick PHP extension\n\nNew Projects\nFor new projects, the fastest way to get up and running is a new Laravel and Streams installation:\n\ncomposer create laravel\/laravel newproject\n\ncd newproject\n\ncomposer require streams\/core:2.0.x-dev\n\nphp artisan serve\n\nLearn more about Streams Core in documentation.\nAdditional Packages\nYou may also want to consider using the following packages:\n\n\nstreams\/api\n\n\nstreams\/ui\n\n\n\nGetting Started\nYour streams project is now ready for you to start coding.\n\n\nConfiguration\n\n\nDebugging\n\n\nThe Basics\nExplore the basics of Streams by example.\n\n\nDefining Streams\n\n\nFundamental Concepts\nDig deeper into the fundamental concepts of Laravel Streams.\n\n\nData Modeling\n\n\nLaravel Development\n\n\nFrontend Development\n\n\nUser Interface\n\n\nAPI Readiness\n\n\nExisting Laravel Projects\nYou can add the Streams platform to existing Laravel projects by requiring the packages you need.\nStreams Core\nThe core package is responsible for the meat and taters; it is the only required package.\ncomposer require streams\/core\n\nUpdating\nFrom within your project, use Composer to update individual packages:\ncomposer update streams\/core --with-dependencies\ncomposer update streams\/api --with-dependencies\ncomposer update streams\/ui --with-dependencies\n\nYou can update your entire project using composer update.\n","href":"\/docs\/installation"},{"id":"introduction","title":"Introduction","sort":0,"stage":"review","enabled":true,"body":"Welcome to Laravel Streams!\nWhat is Streams?\nLaravel Streams is a system of utilities providing an optimized foundation and workflow for Laravel development.\nApplication fundamentals like data modeling, API interaction, UI, control panels, and more are defined with code-configured JSON files and establish best-practices design principles to support your work.\nThe Streams system leans heavily on domain-driven design (DDD). We call these domain abstractions streams, hence our namesake.\nMotivation\nThe ever-changing and widening landscape of web applications, websites, and the like, has stressed the traditions and ideology of popular CMS options. And, after digging into our own CMS engine, we discovered that the problem is in the CMS paradigm. This project results from the complete deconstruction of that paradigm and establishes a new one built upon new fundamental values and principles.\nUse Cases\nLaravel Streams and its components are well suited to build various applications:\n\nWebsites\nPrototyping\nPWA Backbone\nHeadless CMS\nIntegrated CMS\nCode Generator\nApplication Core\nProject Bootstraps\nDevelopment Automation\n\nHow does it work?\nLaravel Streams focuses first on basic JSON descriptions of your data. We call them streams, hence our namesake.\n\/\/ streams\/music.json\n{\n    &quot;name&quot;: &quot;Music&quot;,\n    &quot;fields&quot;: [\n        {\n            &quot;handle&quot;: &quot;id&quot;,\n            &quot;type&quot;: &quot;slug&quot;\n        },\n        {\n            &quot;handle&quot;: &quot;title&quot;,\n            &quot;type&quot;: &quot;string&quot;\n        },\n        {\n            &quot;handle&quot;: &quot;mp3&quot;,\n            &quot;type&quot;: &quot;file&quot;\n        },\n        {\n            &quot;handle&quot;: &quot;artist&quot;,\n            &quot;type&quot;: &quot;relationship&quot;,\n            &quot;config&quot;: {\n                &quot;related&quot;: &quot;artists&quot;\n            }\n        }\n    ]\n}\n\nBy default, Laravel Streams leverages a flat-file database engine. All databases supported by Laravel are inherently supported. An adapter interface allows you to tap into any data source you need.\nBuilding Upon Data\nBy building upon data structure, we can use stream configurations to help drastically reduce the time required to do things like:\n\nValidating the data.\nCRUD'ing the data via a fluent and extensive API.\nGenerate schema from stream configurations.\nGenerate code from stream configurations.\nGenerate stream configurations from data.\nServing and consuming the data via API.\nBuilding comprehensive control panels.\nGenerating quality fake data.\n\nDevelopment Abstraction\nOur overarching focus is to abstract, normalize, and optimize development systems and the work required from many Laravel projects. We try to restrict this to our core focus of data abstraction and access.\nPrinciple Concerns\nLaravel Streams focuses on these fundamental areas of application development.\n\n\nData Modeling\n\n\nLaravel Development\n\n\nFrontend Development\n\n\nUser Interface\n\n\nAPI Readiness\n\n\nWhat's Next?\nTime to get your feet wet!\n\n\nInstallation\n\n\nConfiguration\n\n\nDebugging\n\n\nContributing\n\n\nExamples\n\n\nCore Packages\nKnow what you are looking for already? Dive right into our core packages.\n\n\nStreams Core\n\n\nStreams UI\n\n\nStreams API\n\n\nStreams CLI\n\n\nCommunity Resources\n\n\nDiscord\n\n\nStack Exchange\n\n\nGitHub\n\n\nYouTube\n\n\n","href":"\/docs\/introduction"},{"id":"streams","title":"Data Modeling","category":"core_concepts","intro":"Data modeling is where we begin.","stage":"drafting","enabled":true,"sort":0,"body":"Introduction\nData modeling is the fundamental function of Streams Core. The rest of the platform builds upon streams' data and structure.\n\n\nStreams Core\n\n\nDomain Information\nThe Streams system leans heavily on domain-driven design (DDD). We call these domain abstractions streams, hence our namesake.\nAn example could be configuring a domain model (a stream) for a website's pages, users of an application, or feedback submissions from a form. A stream can define anything anywhere.\n\n\nDefining Streams\n\n\nData Sources\nIf not configured otherwise, streams will utilize the built-in flat-file database. All databases available to Laravel are supported as well.\n\n\nStream Sources\n\n\nDomain Entities\nDomain entities are called entries within the Streams platform. A stream also defines entry attributes or fields that dictate the entry's properties, data-casting, and more.\n\n\nStream Entries\n\n\nEntry Fields\n\n\nField Types\n\n\nManaging Entities\nThe Streams platform separates methods to retrieve and store entries from the objects by using a repository pattern. Entries still provide some convenient methods like save and delete.\n\n\nRepositories\n\n\nQuerying Entries\n\n\n","href":"\/docs\/streams"},{"id":"ui","title":"User Interface","category":"core_concepts","intro":"Incredibly flexible and entirely configurable UI features.","stage":"drafting","enabled":true,"sort":20,"body":"Introduction\nStreams UI provides an extensible interface for creating any user interface your project might require.\nControl Panel\nStreams UI provides an extensible, user-friendly, and performant control panel that gives you control of every detail.\n\n\nControl Panel\n\n\nTheming\n\n\nUI Components\nStreams UI comes with a number of core components.\n\n\nTables\n\n\nForms\n\n\nButtons\n\n\nInput Types\nInput types separate the concerns of data-modeling from data-management and provides a refreshing layer of flexibility between the two.\n\n\nInput Types\n\n\n","href":"\/docs\/ui"},{"id":"addons","link_title":"Addons","title":"Addon Packages","category":"advanced","stage":"outlining","enabled":true,"sort":1,"body":"Introduction\nAddons are composer packages that are specifically designed for Laravel Streams. Addons and can be distributed anywhere composer packages can be distributed (Packagist, SATIS, etc.)\nAddon Development\nCreating addons is a great way to distribute reusable code as well as encapsulate and organize large project components. Before developing addons you should have a basic understanding of integrating with Laravel Streams as well as a general understanding of Composer packages.\nCreating Addons\nUse composer init inside a new directory for your addon package.\nmkdir example-addon\n\ncd example-addon\n\ncomposer init\n\nDefining Addon Packages\nMark your composer package as a streams-addon using the type parameter in order to declare that the package is designed for Laravel Streams.\n\/\/ addons\/example-addon\/composer.json\n{\n    &quot;name&quot;: &quot;myproject\/example-addon&quot;,\n    &quot;description&quot;: &quot;An example addon for my project.&quot;,\n    &quot;type&quot;: &quot;streams-addons&quot;,\n    &quot;require&quot;: {\n        &quot;streams\/core&quot;: &quot;^2.0&quot;\n    },\n    &quot;require-dev&quot;: {\n        &quot;streams\/testing&quot;: &quot;^1.0&quot;\n    },\n    &quot;autoload&quot;: {\n        &quot;psr-4&quot;: {\n            &quot;MyProject\\\\ExampleAddon\\\\&quot;: &quot;src\/&quot;\n        }\n    },\n    &quot;autoload-dev&quot;: {\n        &quot;psr-4&quot;: {\n            &quot;MyProject\\\\ExampleAddon\\\\Tests\\\\&quot;: &quot;tests\/&quot;\n        }\n    },\n    &quot;license&quot;: &quot;MIT&quot;,\n    &quot;prefer-stable&quot;: true,\n    &quot;minimum-stability&quot;: &quot;dev&quot;,\n    &quot;authors&quot;: [\n        {\n            &quot;name&quot;: &quot;Joe Smith&quot;,\n            &quot;email&quot;: &quot;joe@streams.dev&quot;\n        }\n    ],\n    &quot;extra&quot;: {\n        &quot;laravel&quot;: {\n            &quot;providers&quot;: [\n                &quot;MyProject\\\\ExampleAddon\\\\ExampleAddonServiceProvider&quot;\n            ]\n        }\n    }\n}\n\nService Providers\nUsing service providers is the easiest way to integrate with Laravel and Streams. You can specify autodetected service providers using the composer.json file.\n\/\/ addons\/example-addon\/composer.json\n{\n    &quot;extra&quot;: {\n        &quot;laravel&quot;: {\n            &quot;providers&quot;: [\n                &quot;MyProject\\\\ExampleAddon\\\\ExampleAddonServiceProvider&quot;\n            ]\n        }\n    }\n}\n\n\/\/ addons\/example-addon\/src\/ExampleAddonServiceProvider.php\nnamespace MyProject\\ExampleAddon;\n\nuse Illuminate\\Support\\Facades\\View;\nuse Illuminate\\Support\\ServiceProvider;\n\nclass ExampleAddonServiceProvider extends ServiceProvider\n{\n    public function register(): void\n    {\n        \/\/\n    }\n\n    public function boot(): void\n    {\n        \/\/\n    }\n}\n\nLocal Packages\nUsing repository paths you can acheive local-only, application-specific, or development installations of addons.\n\/\/ composer.json\n{\n    &quot;repositories&quot;: [{\n        &quot;type&quot;: &quot;path&quot;,\n        &quot;url&quot;: &quot;addons\/example-addon&quot;,\n        &quot;options&quot;: {\n            &quot;symlink&quot;: true\n        }\n    }]\n}\n\nInstalling Addons\nGenerally speaking, installing an addon requires downloading it with composer and optionally publishing it's assets and any migrations.\n\/\/ composer.json\n{\n    &quot;require&quot;: {\n        \/\/ ...\n        &quot;example\/addon&quot;: &quot;dev-master&quot;\n    }\n}\n\n","href":"\/docs\/core\/addons"},{"id":"applications","title":"Applications","category":"advanced","sort":10,"stage":"outlining","enabled":true,"body":"Introduction\nApplications provides a fundamental interface to configure your application based on request patterns.\nDefining Applications\nApplications are defined using the core.applications stream. Entries are defined using JSON entry files within the \/streams\/apps directory by default.\nThe match value is compared to request URLs to determine the active application.\n\/\/ streams\/apps\/docs.json\n{\n    &quot;match&quot;: &quot;docs.example.com\/*&quot;\n}\n\nApplication Options\nThe following application options are available and support parsing variables.\nLocale\nSet the active locale using the locale property:\n\/\/ streams\/apps\/docs.json\n{\n    &quot;match&quot;: &quot;docs.example.com\/*&quot;,\n    &quot;locale&quot;: &quot;en&quot;\n}\n\nConfiguration\nOverride configuration using the config property:\n\/\/ streams\/apps\/docs.json\n{\n    &quot;match&quot;: &quot;docs.example.com\/*&quot;,\n    &quot;config&quot;: {\n        &quot;app.name&quot;: &quot;Documentation&quot;\n    }\n}\n\nStreams\nYou can overload streams using the streams property:\n\/\/ streams\/apps\/docs.json\n{\n    &quot;match&quot;: &quot;docs.example.com\/*&quot;,\n    &quot;streams&quot;: {\n        &quot;pages&quot;: {\n            &quot;source.path&quot;: &quot;streams\/data\/pages\/docs&quot;\n        }\n    }\n}\n\nAssets\nUse the assets property to register assets by name:\n\/\/ streams\/apps\/docs.json\n{\n    &quot;match&quot;: &quot;docs.example.com\/*?preview=darkmode&quot;,\n    &quot;assets&quot;: {\n        &quot;variable&quot;: &quot;epic\/script.js&quot;,\n        &quot;theme.css&quot;: &quot;your\/theme\/dark.css&quot;,\n        &quot;theme.js&quot;: &quot;your\/theme\/dark.js&quot;,\n        &quot;theme-bundle&quot;: [&quot;theme.css&quot;, &quot;theme.js&quot;]\n    }\n}\n\n{{ Asset::load(&quot;random&quot;) }}\n{{ Asset::load(&quot;theme-bundle&quot;) }}\n\nRoutes\nUse the routes property to register routes by middleware group:\n\/\/ streams\/apps\/docs.json\n{\n    &quot;match&quot;: &quot;docs.example.com\/*?preview=login&quot;,\n    &quot;routes&quot;: {\n        &quot;web&quot;: {\n            &quot;\/login&quot;: {\n                &quot;uses&quot;: &quot;App\\\\Http\\\\Controller\\\\Alternate@login&quot;\n            }\n        }\n    }\n}\n\nPolicies\nUse the policies property to register policies by name:\n\/\/ streams\/apps\/docs.json\n{\n    &quot;match&quot;: &quot;docs.example.com\/*?preview=login&quot;,\n    &quot;policies&quot;: {\n        &quot;custom-testing-array-policy&quot;: [&quot;Your\\\\Policy&quot;, &quot;method&quot;],\n        &quot;custom-testing-invokable-policy&quot;: &quot;You\\\\InvokablePolicy&quot;,\n        &quot;CustomProviderService::class&quot;: &quot;Your\\\\Policy&quot;\n    }\n}\n\nListeners\nUse the listeners property to register listeners by event name:\n\/\/ streams\/apps\/docs.json\n{\n    &quot;match&quot;: &quot;docs.example.com\/*?preview=feature&quot;,\n    &quot;events&quot;: {\n        &quot;example.event&quot;: [\n            &quot;App\\\\Event\\\\Listener\\\\FeatureListener&quot;\n        ]\n    }\n}\n\nProviders\nThe providers property specifies service providers to register.\n\/\/ streams\/apps\/docs.json\n{\n    &quot;match&quot;: &quot;docs.example.com\/*?preview=feature&quot;,\n    &quot;providers&quot;: [\n        &quot;App\\\\Providers\\\\FeatureProvider&quot;\n    ]\n}\n\nMiddleware\nThe middleware property specifies grouped middleware to register.\n\/\/ streams\/apps\/docs.json\n{\n    &quot;match&quot;: &quot;docs.example.com\/*?preview=feature&quot;,\n    &quot;middleware&quot;: {\n        &quot;web&quot;: [\n            &quot;App\\\\Http\\\\Middleware\\\\ExampleMiddleware&quot;\n        ]\n    }\n}\n\nCommands\nThe commands property specifies Artisan commands to register.\n\/\/ streams\/apps\/docs.json\n{\n    &quot;match&quot;: &quot;docs.example.com\/*?preview=feature&quot;,\n    &quot;commands&quot;: [\n        &quot;App\\\\Console\\\\ExampleCommand&quot;\n    ]\n}\n\nSchedules\nThe schedules property specifies scheduled commands to register.\n\/\/ streams\/apps\/docs.json\n{\n    &quot;match&quot;: &quot;docs.example.com\/*?preview=feature&quot;,\n    &quot;schedules&quot;: {\n        &quot;* * * * *&quot;: [\n            &quot;App\\\\Console\\\\ExampleCommand&quot;,\n        ],\n        &quot;dailyAt|13:00&quot;: [\n            &quot;App\\\\Console\\\\AnotherCommand&quot;,\n        ]\n    }\n}\n\nMulti-Tenancy\nApplications provide the backbone functionality for building multi-tenancy applications.\n\/\/ streams\/apps\/accounts.json\n{\n    &quot;match&quot;: &quot;*.example.com\/*&quot;,\n    &quot;config&quot;: {\n        &quot;app.name&quot;: &quot;My Account&quot;,\n        &quot;database.default&quot;: &quot;{request.parsed.domain.0}&quot;,\n        &quot;streams.core.data_path&quot;: &quot;streams\/data\/{request.parsed.domain.0}&quot;\n    },\n    &quot;users&quot;: {\n        &quot;source.table&quot;: &quot;users_{request.parsed.domain.0}&quot;\n    }\n}\n\nLocalization\nApplication switching provides the backbone functionality for building localized applications.\n\/\/ streams\/apps\/localized.json\n{\n    &quot;match&quot;: &quot;*.example.com\/*&quot;,\n    &quot;locale&quot;: &quot;{request.parsed.domain.0}&quot;,\n    &quot;pages&quot;: {\n        &quot;source.path&quot;: &quot;streams\/data\/pages\/{request.parsed.domain.0}&quot;\n    }\n}\n\nResources\n\n\n@todo  Example Applications\n\n\n","href":"\/docs\/core\/applications"},{"id":"array","title":"Array Type","link_title":"Array","category":"field_types","intro":"The `array` field type stores `key:value` array data.","stage":"drafting","enabled":true,"body":"Overview\nThe array field type is used for storing indexed arrays. Items can be simple or complex types. By default, any item type is valid.\n\/\/ streams\/example.json\n&quot;fields&quot;: {\n    &quot;items&quot;: {\n        &quot;type&quot;: &quot;array&quot;\n    }\n}\n\nData Structure\n{\n    &quot;items&quot;: [\n        &quot;John Doe&quot;,\n        &quot;Jane Smith&quot;\n    ]\n}\n\nBasic array access:\n\/\/ Array access\n{{ $entry-&gt;items[0] }}\n\n@foreach ($entry-&gt;items as $index =&gt; $value)\n{{ $index }}: {{ $value }}\n@endforeach\n\n\nDecorator Usage\nThe decorated value provides collection access to the data.\n\/\/ Decorated value\n{{ $entry-&gt;items()-&gt;implode(', ') }}\n\n\nMethods\n@todo Generate methods from @docs\nConfiguration\n@todo Generate config options from class::configuration\n{\n\/\/ streams\/example.json\n&quot;fields&quot;: {\n    &quot;items&quot;: {\n        &quot;type&quot;: &quot;array&quot;,\n        &quot;config&quot;: {\n            &quot;wrapper&quot;: &quot;array|collection|App\\\\MyCollection&quot;\n        }\n    }\n}\n}\n\nItems\nUse the items configuration to specify the allowed item types using field configurations. If specified, each item must be valid against any of the provided types.\n\/\/ streams\/example.json\n&quot;fields&quot;: {\n    &quot;items&quot;: {\n        &quot;type&quot;: &quot;array&quot;,\n        &quot;config&quot;: {\n            &quot;wrapper&quot;: &quot;array|collection|App\\\\MyCollection&quot;,\n            &quot;items&quot;: [\n                { &quot;type&quot;: &quot;integer&quot; },\n                { &quot;type&quot;: &quot;string&quot; },\n                {\n                    &quot;type&quot;: &quot;object&quot;,\n                    &quot;config&quot;: {\n                        &quot;schemas&quot;: [\n                            { &quot;stream&quot;: &quot;addresses&quot; }\n                        ]\n                    }\n                },\n            ]\n        }\n    }\n}\n\n","href":"\/docs\/core\/array"},{"id":"assets","title":"Assets","category":"frontend","status":"drafting","enabled":true,"sort":2,"intro":null,"body":"Introduction\nThe Streams platform comes with a fluid and highly extensible asset management tool for organizing, registering, customizing, and including your frontend assets.\nAsset Collections\nAssets are organized into collections which can be accessed and output later. You can access or create an asset collection using the Assets facade or alias.\nuse Streams\\Core\\Support\\Facades\\Assets;\n\n$collection = Assets::collection('footer');\n\n{!! Assets::collection('footer') !!} \/\/ Outputs asset tags&quot;\n\nAdding Assets\nUse the add() method to add an asset to a collection.\nAssets::collection('footer')-&gt;add('resources\/js\/start.js');\n\n{!! Assets::collection('footer')-&gt;add('resources\/js\/start.js') !!}\n\nAsset Sources\nThe first and only argument should be the source of the asset. The following asset sources are supported out of the box.\nPaths in the Filesystem\nAny non-executable asset path relative to the application's public root may be used.\n{!! Assets::collection('footer')-&gt;add('js\/example.js') !!} \/\/ \/public\/js\/example.js\n\n\nRemote URLs\nThe URL of a remote asset may also be used. The allow_url_fopen PHP directive must be enabled to output inline or content methods for remote files.\n{!! Assets::collection('footer')-&gt;add('https:\/\/cdn.com\/js\/example.js') !!}\n\nHinted Assets\nHinted assets are prefixed with a namespace:: that is replaced with a registered path.\n\/\/ \/public\/vendor\/anomaly\/streams\/ui\/js\/example.js@endverbatim\n{!! Assets::collection('footer')-&gt;add('ui::js\/example.js') !!} \n\n\/\/ https:\/\/cdn.domain.com\/js\/example.js\n{!! Assets::collection('footer')-&gt;add('cdn::js\/example.js') !!} \n\nNamed Assets\nUse the register() method to name one or more assets. The assets parameter can be any valid source or array of sources.\nuse Streams\\Core\\Support\\Facades\\Assets;\n\nAssets::register('ui\/tables', [\n    'ui::js\/tables.js',\n    'ui::css\/tables.css',\n]);\n\nYou can now use the collection's load() method to load the assets by name.\n@verbatim{!! Assets::collection('footer')-&gt;load('ui\/tables') !!}\n\nAssets::collection('footer')-&gt;load('ui\/tables');\n\nYou can also render the output of the named single assets.\nAssets::tags('ui\/tables');\n\nOutputting Assets\nUse output methods to include assets from a collection.\nGenerating URLs\nUse the url() method to return a single asset URL.\n{!! Assets::url('ui::js\/example.js') !!}\n\nYou can also use the urls() method on a collection to return all URLs.\n{!! Assets::collection('urls')-&gt;urls() !!}\n\nIncluding Assets\nUse the tag() method to return a single asset URL. An attributes array can be passed as a second parameter.\n{!! Assets::tag('ui::js\/example.js', [\n    'async' =&gt; true\n]) !!}\n\nYou can also use the tags() method on a collection to return all tags.\n{!! Assets::collection('footer')-&gt;tags() !!}\n\nRegistering Paths\nUse the addPath() method to register a namespace and path. The path parameter can be any path in the filesystem relative to the application's public root or a remote URL prefix.\nuse Streams\\Core\\Support\\Facades\\Assets;\n\nAssets::addPath('ui', 'vendor\/anomaly\/streams\/ui');\nAssets::addPath('cdn', 'https:\/\/cdn.domain.com');\n\nYou can now use the above path hints to resolve assets.\n{!! Assets::collection('footer')-&gt;add('ui::js\/example.js') !!} \/\/ \/vendor\/anomaly\/streams\/ui\/js\/example.js\n{!! Assets::collection('footer')-&gt;add('cdn::js\/example.js') !!} \/\/ https:\/\/cdn.domain.com\/js\/example.js\n\n{!! Assets::url('ui::js\/example.js') !!}\n{!! Assets::url('cdn::js\/example.js') !!}\n\n","href":"\/docs\/core\/assets"},{"id":"boolean","title":"Boolean Type","link_title":"Boolean","intro":"Store boolean values.","category":"field_types","stage":"drafting","enabled":true,"body":"Overview\nThe boolean field type stores true\/false values.\n\/\/ streams\/users.json\n&quot;fields&quot;: {\n    &quot;enabled&quot;: {\n        &quot;type&quot;: &quot;boolean&quot;\n    }\n}\n\nData Structure\n{\n    &quot;enabled&quot;: true\n}\n\nBasic value access displays the stored key value:\n\/\/ Basic access\n{{ $entry-&gt;enabled }}\n\nDecorator Usage\nBoolean types also provide decorated values.\n\/\/ Decorated value\n@if ($entry-&gt;enabled()-&gt;isTrue())\n    \/\/ ...\n@endif\n\nMethods\n@todo Generate methods from @docs\nConfiguration\n@todo Generate config options from class::configuration\n\/\/ streams\/users.json\n&quot;fields&quot;: {\n    &quot;enabled&quot;: {\n        &quot;type&quot;: &quot;boolean&quot;,\n        &quot;config&quot;: {\n            &quot;default&quot;: false\n        }\n    }\n}\n\n","href":"\/docs\/core\/boolean"},{"id":"caching","title":"Caching","category":"basics","intro":null,"sort":21,"stage":"drafting","enabled":true,"body":"Introduction\nStreams Core provides a convenient API to link Laravel cache data to a Stream. When caching in this way, you can flush all cached items related to a Stream together.\nConfiguration\n\/\/streams\/examples.json\n{\n    &quot;config&quot;: {\n        &quot;cache&quot;: {\n            &quot;enabled&quot;: &quot;true&quot;,\n            &quot;store&quot;: &quot;default&quot;,\n            &quot;ttl&quot;: 3600\n        }\n    }\n}\n\nCache Usage\nThe Cache Instance\nTo obtain a Stream-linked cache instance, you may use the cache() method on the desired Stream instance:\n$cache = Streams::make('examples')-&gt;cache();\n\n$cache-&gt;get('key');\n\nRetrieving Items\nUse the get method to retrieve items from the cache. If the item does not exist in the cache, null will be returned. You may pass a second argument specifying the default value to return if the item doesn't exist:\n$cache = Streams::make('examples')-&gt;cache();\n\n$value = $cache-&gt;get('key');\n\n$value = $cache-&gt;get('key', 'default');\n\nYou may also pass a closure as the default value. The get method will return the closure result if the specified item does not exist in the cache. Using a closure allows you to defer the retrieval of expensive default values until they are needed:\n$stream = Streams::make('examples');\n\n$value = $stream-&gt;cache()-&gt;get('key', function () use ($stream) {\n    return $stream-&gt;entries()-&gt;all();\n});\n\nChecking Items\nUse the exists method to check if an item exists in cache:\nif (Streams::make('examples')-&gt;cache()-&gt;has('key')) {\n    \/\/ We have it!\n}\n\nIncrementing\/Decrementing Values\nUse the increment and decrement methods to increment or decrement the value of cached integer value:\n$cache = Streams::make('examples')-&gt;cache();\n\n$cache-&gt;increment('key');\n$cache-&gt;increment('key', $amount);\n\n$cache-&gt;decrement('key');\n$cache-&gt;decrement('key', $amount);\n\nRetrieve &amp; Store\nUse the remember method to retrieve an item from the cache and store a default value if the requested item doesn't exist.\n$value = Streams::make('examples')-&gt;cache()-&gt;remember('key', $seconds, function () {\n    return Streams::entries('examples')-&gt;get();\n});\n\nRetrieve &amp; Delete\nUse the pull method to retrieve an item from the cache and then delete the item.\n$value = Streams::make('examples')-&gt;cache()-&gt;pull('key');\n\nStoring Items\nUse the put method to store items in the cache:\nStreams::make('examples')-&gt;cache()-&gt;put('key', 'value', $seconds);\n\nYou can also pass a DateTime instance instead of seconds:\nStreams::make('examples')-&gt;cache()-&gt;put('key', 'value', now()-&gt;addMinutes(10));\n\nIf the storage time is not passed to the put method, the item will be stored indefinitely:\nStreams::make('examples')-&gt;cache()-&gt;put('key', 'value');\n\nStore If Not Present\nUse the add method to store items in the cache only if they do not already exist:\nStreams::make('examples')-&gt;cache()-&gt;add('key', 'value', $seconds);\n\nStore Forever\nUse the forever method to store items in the cache indefinitely:\nStreams::make('examples')-&gt;cache()-&gt;forever('key', 'value');\n\n\nItems that are stored &quot;forever&quot; may be removed under some circumstances.\n\nRemoving Items\nUse the forget method to remove items from the cache:\nStreams::make('examples')-&gt;cache()-&gt;forget('key');\n\nYou can also remove items by providing a zero or negative number of seconds:\nStreams::make('examples')-&gt;cache()-&gt;put('key', 'value', 0);\n\nStreams::make('examples')-&gt;cache()-&gt;put('key', 'value', -5);\n\n\nStream entry changes automatically forget\/flush cache items.\n\nRemoving All Items\nYou can clear the entire cache using the flush method:\nStreams::make('examples')-&gt;cache()-&gt;flush();\n\n\nThe flush method only flushes linked cache.\n\nRelated Documentation\n\n\nQuery Cache\n\n\nAPI Cache\n\n\nLaravel Cache\n\n\n@todo Response Cache\n\n\n","href":"\/docs\/core\/caching"},{"id":"configuration","title":"Configuration","category":"getting_started","intro":"Configuring the core.","sort":2,"enabled":true,"body":"Configuration Files\nPublished configuration files reside in config\/streams\/.\n\u251c\u2500\u2500 config\/streams\/\n\u2502   \u2514\u2500\u2500 core.php\n\nPublishing Configuration\nUse the following command to publish configuration files.\nphp artisan vendor:publish --provider=Streams\\\\Core\\\\StreamsServiceProvider --tag=config\n\nThe above command will copy configuration files from their package location to the directory mentioned above so that you can modify them directly and commit them to your version control system.\nConfiguring Streams Core\nBelow are the contents of the published configuration file:\n\/\/ config\/streams\/core.php\nreturn [\n\n    \/**\n     * Specify the default directory for VCS compatible (file based) data.\n     *\/\n    'data_path' =&gt; env('STREAMS_DATA_PATH', 'streams\/data'),\n\n    \/**\n     * Specify the default source adapter for streams.\n     *\/\n    'default_source' =&gt; env('STREAMS_SOURCE', 'filebase'),\n\n    \/**\n     * Configurable options for source adapters.\n     *\/\n    'sources' =&gt; [\n\n        'filebase' =&gt; [\n\n            'default_format' =&gt; env('STREAMS_DEFAULT_FORMAT', 'json'),\n\n            'formats' =&gt; [\n                'php' =&gt; \\Streams\\Core\\Criteria\\Format\\Php::class,\n                'json' =&gt; \\Streams\\Core\\Criteria\\Format\\Json::class,\n                'yaml' =&gt; \\Streams\\Core\\Criteria\\Format\\Yaml::class,\n                'md' =&gt; \\Streams\\Core\\Criteria\\Format\\Markdown::class,\n                'tpl' =&gt; \\Streams\\Core\\Criteria\\Format\\Template::class,\n            ],\n        ],\n    ],\n\n    \/**\n     * Configure the default field types.\n     *\/\n    'field_types' =&gt; [\n\n        \/\/ Numbers\n        'number' =&gt; \\Streams\\Core\\Field\\Type\\Number::class,\n        'integer' =&gt; \\Streams\\Core\\Field\\Type\\Integer::class,\n        'decimal' =&gt; \\Streams\\Core\\Field\\Type\\Decimal::class,\n\n        \/\/ Strings\n        'string' =&gt; \\Streams\\Core\\Field\\Type\\Str::class,\n\n        'url' =&gt; \\Streams\\Core\\Field\\Type\\Url::class,\n        'uuid' =&gt; \\Streams\\Core\\Field\\Type\\Uuid::class,\n        'hash' =&gt; \\Streams\\Core\\Field\\Type\\Hash::class,\n        'slug' =&gt; \\Streams\\Core\\Field\\Type\\Slug::class,\n        'email' =&gt; \\Streams\\Core\\Field\\Type\\Email::class,\n        'encrypted' =&gt; \\Streams\\Core\\Field\\Type\\Encrypted::class,\n\n        \/\/ Markup\n        'markdown' =&gt; \\Streams\\Core\\Field\\Type\\Markdown::class,\n        'template' =&gt; \\Streams\\Core\\Field\\Type\\Template::class,\n\n        \/\/ Boolean\n        'boolean' =&gt; \\Streams\\Core\\Field\\Type\\Boolean::class,\n\n        \/\/ Dates\n        'datetime' =&gt; \\Streams\\Core\\Field\\Type\\Datetime::class,\n        'date' =&gt; \\Streams\\Core\\Field\\Type\\Date::class,\n        'time' =&gt; \\Streams\\Core\\Field\\Type\\Time::class,\n\n        \/\/ Arrays\n        'array' =&gt; \\Streams\\Core\\Field\\Type\\Arr::class,\n\n        \/\/ Selections\n        'select' =&gt; \\Streams\\Core\\Field\\Type\\Select::class,\n        'multiselect' =&gt; \\Streams\\Core\\Field\\Type\\Multiselect::class,\n\n        \/\/ Objects\n        'prototype' =&gt; \\Streams\\Core\\Field\\Type\\Prototype::class,\n        'object' =&gt; \\Streams\\Core\\Field\\Type\\Structure::class,\n        'image' =&gt; \\Streams\\Core\\Field\\Type\\Image::class,\n        'file' =&gt; \\Streams\\Core\\Field\\Type\\File::class,\n\n        \/\/ Streams\n        'entry' =&gt; \\Streams\\Core\\Field\\Type\\Entry::class,\n        'entries' =&gt; \\Streams\\Core\\Field\\Type\\Entries::class,\n\n        \/\/ Relationships\n        'multiple' =&gt; \\Streams\\Core\\Field\\Type\\Multiple::class,\n        'polymorphic' =&gt; \\Streams\\Core\\Field\\Type\\Polymorphic::class,\n        'relationship' =&gt; \\Streams\\Core\\Field\\Type\\Relationship::class,\n\n        \/\/ Miscellaneous\n        'color' =&gt; \\Streams\\Core\\Field\\Type\\Color::class,\n    ],\n\n    \/**\n     * Enabling this feature automatically\n     * generages alt tags when not specified.\n     *\/\n    'auto_alt' =&gt; env('STREAMS_AUTO_ALT', true),\n\n    \/**\n     * Enabling this feature automatically\n     * generates version control query\n     * parameters when generating\n     * image URLs and output.\n     *\/\n    'version_images' =&gt; env('STREAMS_VERSION_IMAGES', true),\n\n    'markdown' =&gt; [\n        'configs' =&gt; [\n            'commonmark' =&gt; [\n                'use_asterisk' =&gt; true,\n                'use_underscore' =&gt; true,\n                'enable_strong' =&gt; true,\n                'enable_em' =&gt; true,\n                'unordered_list_markers' =&gt; [ '*', '+', '-' ],\n            ],\n            'disallowed_raw_html' =&gt; [\n                'disallowed_tags' =&gt; [\n                    'title',\n                    'textarea',\n                    'style',\n                    'xmp',\n                    'iframe',\n                    'noembed',\n                    'noframes',\n                    'script',\n                    'plaintext',\n                ],\n            ],\n        ],\n        'extensions' =&gt; [\n            \\League\\CommonMark\\Extension\\CommonMark\\CommonMarkCoreExtension::class,\n            \\League\\CommonMark\\Extension\\Autolink\\AutolinkExtension::class,\n            \\League\\CommonMark\\Extension\\DisallowedRawHtml\\DisallowedRawHtmlExtension::class,\n            \\League\\CommonMark\\Extension\\Strikethrough\\StrikethroughExtension::class,\n            \\League\\CommonMark\\Extension\\Table\\TableExtension::class,\n            \\League\\CommonMark\\Extension\\TaskList\\TaskListExtension::class,\n        ],\n    ],\n];\n\n","href":"\/docs\/core\/configuration"},{"id":"date","title":"Date Type","link_title":"Date","intro":"Store date values.","category":"field_types","stage":"drafting","enabled":true,"body":"Overview\nThe date field type stores only date.\n\/\/ streams\/example.json\n&quot;fields&quot;: {\n    &quot;starts_at&quot;: {\n        &quot;type&quot;: &quot;date&quot;\n    }\n}\n\nConfiguration\n@todo Generate config options from class::configuration\n\/\/ streams\/example.json\n&quot;fields&quot;: {\n    &quot;starts_at&quot;: {\n        &quot;type&quot;: &quot;date&quot;,\n        &quot;config&quot;: {\n            &quot;default&quot;: &quot;today&quot;\n        }\n    }\n}\n\nData Structure\n{\n    &quot;starts_at&quot;: &quot;2021-01-01&quot;\n}\n\nBasic value access returns the stored value:\n\/\/ Basic access\n{{ $entry-&gt;starts_at }}\n\nDecorator Usage\nDate types also provide decorated values which returns a Carbon instance.\n\/\/ Decorated value\n{{ $entry-&gt;startsAt()-&gt;isWeekend() }}\n\nMethods\n@todo Generate methods from @docs\n","href":"\/docs\/core\/date"},{"id":"datetime","title":"Datetime Type","link_title":"Datetime","intro":"Store datetime values.","category":"field_types","stage":"drafting","enabled":true,"body":"Overview\nThe datetime field type stores both date and time.\n\/\/ streams\/example.json\n&quot;fields&quot;: {\n    &quot;starts_at&quot;: {\n        &quot;type&quot;: &quot;datetime&quot;\n    }\n}\n\nConfiguration\n@todo Generate config options from class::configuration\n\/\/ streams\/example.json\n&quot;fields&quot;: {\n    &quot;starts_at&quot;: {\n        &quot;type&quot;: &quot;datetime&quot;,\n        &quot;config&quot;: {\n            &quot;default&quot;: &quot;now&quot;\n        }\n    }\n}\n\nData Structure\n{\n    &quot;starts_at&quot;: &quot;2021-01-01 09:30:00&quot;\n}\n\nBasic value access returns the stored value:\n\/\/ Basic access\n{{ $entry-&gt;starts_at }}\n\nDecorator Usage\nDatetime types also provide decorated values which returns a Carbon instance.\n\/\/ Decorated value\n{{ $entry-&gt;startsAt()-&gt;diffForHumans() }}\n\nMethods\n@todo Generate methods from @docs\n","href":"\/docs\/core\/datetime"},{"id":"decimal","title":"Decimal Type","link_title":"Decimal","intro":"Store fixed-precision decimal values.","category":"field_types","stage":"drafting","enabled":true,"body":"Overview\nThe decimal field type stores fixed-precision decimal values. If you need to support floating point numbers, check out the number field type.\n\/\/ streams\/example.json\n&quot;fields&quot;: {\n    &quot;price&quot;: {\n        &quot;type&quot;: &quot;decimal&quot;,\n        &quot;config&quot;: {\n            &quot;decimals&quot;: 2\n        }\n    }\n}\n\nConfiguration\n@todo Generate config options from class::configuration\nData Structure\n{\n    &quot;price&quot;: 89.95\n}\n\nBasic value access displays the stored value:\n\/\/ Basic access\n{{ $entry-&gt;price }}\n\nDecorator Usage\nBoolean types also provide decorated values.\n\/\/ Decorated value\n@if ($entry-&gt;price()-&gt;isOdd())\n    \/\/ ...\n@endif\n\nMethods\n@todo Generate methods from @docs\n","href":"\/docs\/core\/decimal"},{"id":"encrypted","title":"Encrypted Text","link_title":"Encrypted","intro":"Store non-readable text that can be decrypted.","category":"field_types","stage":"drafting","enabled":true,"body":"Overview\nThe encrypted field type stores a two-way encrypted string.\n\/\/ streams\/example.json\n&quot;fields&quot;: {\n    &quot;secret&quot;: {\n        &quot;type&quot;: &quot;encrypted&quot;\n    }\n}\n\nData Structure\n{\n    &quot;secret&quot;: &quot;eyJpdiI6IkRKSWdqMDVDUXYzR3pJRTkwZjJZRmc9PSIsInZhbHVlIjoic3NrUHF4RE1jVnFBVFIrNG85Rjh4VlZkU1kzQUs5VEp5b3Y5VVU2cUZYYz0iLCJtYWMiOiIyNWFhZTM1MDBhZTdmNDZiY2E2NzM2NjE1NjYzYThmMmMzYTczNGJhM2VlNjBiZDdkZmNlOGFhMWVkZmQwN2RjIiwidGFnIjoiIn0=&quot;\n}\n\nBasic value access displays encrypted value:\n\/\/ Basic access\n{{ $entry-&gt;secret }}\n\n\nDecorator Usage\nTo get anything out of your stored value you will need to expand it.\n\/\/ Decorated value\n{{ $entry-&gt;secret()-&gt;decrypt() }}\n\n\nMethods\n@todo Generate methods from @docs\nConfiguration\n@todo Generate config options from class::configuration\n","href":"\/docs\/core\/encrypted"},{"id":"extending","title":"Extending","category":"advanced","intro":"Extend and customize Streams Core.","stage":"outlining","enabled":true,"sort":2,"body":"Introduction\nStreams architecture is designed to support systemic customization and extension.\nBefore continuing, please familiarize yourself with Laravel's service container.\nThe Basics\nBelow is essential knowledge on how to extend streams core.\nMacros\nAll basic services and components are &quot;macroable&quot; and allow direct extension via Laravel macros. Typically, you should declare collection macros in the boot method of a service provider.\nuse Streams\\Core\\Stream\\Stream;\nuse Streams\\Ui\\Table\\TableBuilder;\n\nStream::macro('table', function ($attributes = []) {\n\n    \/\/ Grab the UI config off the stream.\n    $configuration = Arr::get($this-&gt;ui, 'table', []);\n\n    $configuration = Arr::undot($configuration);\n\n    \/\/ Merge configured and passed attributes.\n    $attributes = array_merge($configuration, $attributes);\n\n    \/\/ Set the stream.\n    $attributes['stream'] = $this;\n\n    return new TableBuilder($attributes);\n});\n\n$table = Streams::make('contacts')-&gt;table();\n\nCallbacks\nWorkflows\nView Overrides\nParsing\nAddon Development\n","href":"\/docs\/core\/extending"},{"id":"fields","title":"Fields","category":"core_concepts","intro":null,"enabled":true,"sort":10,"body":"Introduction\nFields represent the type and characteristics of your stream data. For example a &quot;name&quot; field would likely be a string field type.\nFields are strictly concerned with data. Please see the UI package for configuring field inputs.\nDefining Fields\nFields can be defined within the JSON configuration for your streams. You can get started by simply defining fields by handle and their type respectively.\nBasic Example\n\/\/ streams\/contacts.json\n{\n    &quot;fields&quot;: [\n        {\n            &quot;handle&quot;: &quot;title&quot;,\n            &quot;type&quot;: &quot;string&quot;\n        }\n    ]\n}\n\nFull Example\nTo define more information about the field use an array:\n\/\/ streams\/contacts.json\n{\n    &quot;fields&quot;: [\n        {\n            &quot;handle&quot;: &quot;title&quot;,\n            &quot;name&quot;: &quot;Title&quot;,\n            &quot;description&quot;: &quot;The title of the film.&quot;,\n            &quot;type&quot;: &quot;string&quot;,\n            &quot;rules&quot;: [&quot;min:4&quot;],\n            &quot;config&quot;: {\n                &quot;default&quot;: &quot;Untitled&quot;\n            },\n            &quot;example&quot;: &quot;Star Wars: The Force Awakens&quot;\n        }\n    ]\n}\n\nField Validation\nDefine Laravel validation rules for fields and they will be merged the stream validation rules.\n\/\/ streams\/contacts.json\n{\n    &quot;fields&quot;: [\n        {\n            &quot;handle&quot;: &quot;name&quot;,\n            &quot;type&quot;: &quot;string&quot;,\n            &quot;rules&quot;: [&quot;required&quot;, &quot;max:100&quot;]\n        },\n        {\n            &quot;handle&quot;: &quot;email&quot;,\n            &quot;type&quot;: &quot;email&quot;,\n            &quot;rules&quot;: [&quot;required&quot;, &quot;email:rfc,dns&quot;]\n        },\n        {\n            &quot;handle&quot;: &quot;company&quot;,\n            &quot;type&quot;: &quot;string&quot;,\n            &quot;rules&quot;: [&quot;required&quot;, &quot;unique&quot;]\n        }\n    ]\n}\n\nBasic Usage\nValues are stored as an image source\nImage::make($entry-&gt;profile_image)-&gt;url();\n\nField Decorators\nField decorators provide expanded function to entry attributes like a universal presenter.\nThe below example demonstrates the image field decorator:\n$entry-&gt;decorate('profile_image')-&gt;url();\n\nYou may also use magic methods derived from &quot;camel casing&quot; the field's handle to invoke decoration.\n$entry-&gt;profileImage()-&gt;url();\n\nField Types\nThe field type is responsible for validating, casting, and more for its specific data type.\n\n\nArray Type (drafting)\n\n\nBoolean Type (drafting)\n\n\nDate Type (drafting)\n\n\nDatetime Type (drafting)\n\n\nDecimal Type (drafting)\n\n\nEncrypted Text (drafting)\n\n\nHash Text (drafting)\n\n\nInteger Type (drafting)\n\n\nMarkdown Type (drafting)\n\n\nMultiselect Type (drafting)\n\n\nNumber Type (drafting)\n\n\nObject Type (drafting)\n\n\nRelationship Type (drafting)\n\n\nSelect Type (drafting)\n\n\nSlug Type (drafting)\n\n\nString Type (drafting)\n\n\nTime Type (drafting)\n\n\nURL Type (drafting)\n\n\nRelationship\n{\n    &quot;type&quot;: &quot;relationship&quot;,\n    &quot;config&quot;: {\n        &quot;related&quot;: &quot;stream&quot;\n    }\n}\n\nMultiple\n{\n    &quot;type&quot;: &quot;multiple&quot;,\n    &quot;config&quot;: {\n        &quot;related&quot;: &quot;stream&quot;\n    }\n}\n\nFile\n{\n    &quot;type&quot;: &quot;file&quot;,\n    &quot;config&quot;: {\n        &quot;path&quot;: &quot;storage::uploads&quot;\n    }\n}\n\nImage\n{\n    &quot;type&quot;: &quot;image&quot;,\n    &quot;config&quot;: {\n        &quot;path&quot;: &quot;storage::uploads.img&quot;\n    }\n}\n\n","href":"\/docs\/core\/fields"},{"id":"hash","title":"Hash Text","link_title":"Hash","intro":"Store non-readable, one-way hashed text.","category":"field_types","enabled":true,"stage":"drafting","body":"Overview\nThe hashed field type stores a one-way hashed string.\n\/\/ streams\/example.json\n&quot;fields&quot;: {\n    &quot;secret&quot;: {\n        &quot;type&quot;: &quot;hashed&quot;\n    }\n}\n\nData Structure\n{\n    &quot;secret&quot;: &quot;$2y$10$bd4ATnlv.fApn0OGSMwU7.rBOUMP2cBaFQY20NFTNdpGCYUIZMEMm&quot;\n}\n\nBasic value access displays encrypted value:\n\/\/ Basic access\n{{ $entry-&gt;secret }}\n\n\nDecorator Usage\nTo get anything out of your stored value you will need to expand it.\n\/\/ Decorated value\n@if ($entry-&gt;secret()-&gt;check('check me'))\n    \/\/ Matches\n@endif\n\n\nMethods\n@todo Generate methods from @docs\nConfiguration\n@todo Generate config options from class::configuration\n","href":"\/docs\/core\/hash"},{"id":"images","title":"Images","category":"frontend","intro":null,"enabled":true,"sort":10,"body":"Introduction\nThe Streams platform comes with a fluid and highly extensible image handling and manipulation tool that leans heavily on the fantastic Intervention Image.\nReading Images\nTo get started, use the Images facade to create a new image for working with.\nuse Streams\\Core\\Support\\Facades\\Images;\n\n$image = Images::make('img\/foo.jpg');\n\nThe facade is aliased for use in views as well:\n{!! Images::make('resources\/img\/foo.jpg') !!}\n\nImage Sources\nThe first and only argument should be the source image to display. The following sources are supported out of the box:\nPaths in the Filesystem\nAny image path relative to the application root may be used.\n{!! Images::make('resources\/img\/foo.jpg') !!}\n\nConfigured Storage Disks\nYou may use any configured storage location as an image source.\n{!! Images::make('public:\/\/img\/foo.jpg') !!}\n\nIf the file is not found relative to the base path of your application, the default public disk will be attempted.\n{!! Images::make('img\/foo.jpg') !!}\n\nRemote URLs\nThe URL of a remote image may also be used. The allow_url_fopen PHP directive must be enabled to use remote image sources.\n{!! Images::make('https:\/\/example.com\/img\/foo.jpg') !!}\n\nRemote images are cached locally. To use remote images without caching locally just use regular &lt;img&gt; tags.\nNamed Images\nUse named images to register image variables:\nRegistering Images\nYou may regiter iamges by name using the register method:\nuse Streams\\Core\\Support\\Facades\\Images;\n\nImages::register('logo.jpg', 'images\/logo.jpg');\n\n{!! Images::make('logo.jpg')-&gt;fit(300, 500)-&gt;quality(60) !!}\n\nEditing Images\nAfter you initiat a new image instance with Images::make(), you can use the below manipulation methods.\nChain methods together for more comple manipulations.\nuse Streams\\Core\\Support\\Facades\\Images;\n\n$image = Images::make('img\/foo.jpg')\n    -&gt;fit(300, 500)\n    -&gt;quality(60)\n    -&gt;orientate();\n\n{!! Images::make('resources\/img\/foo.jpg')\n    -&gt;fit(300, 500)\n    -&gt;quality(60)\n    -&gt;orientate() !!}\n\nResizing Images\nUse the following methods to resize images.\n\n\nresize()\n\n\nwiden()\n\n\nheighten()\n\n\nfit()\n\n\ncrop()\n\n\ntrim()\n\n\nAdjusting Images\nUse the following methods to adjust various aspects of images.\n\n\nencode()\n\n\ngamma()\n\n\nbrightness()\n\n\ncontrast()\n\n\ncolorize()\n\n\ngreyscale()\n\n\ninvert()\n\n\nmask()\n\n\nflip()\n\n\nquality()\nAdditionally, you may use the quality method to adjust the quality alone of JPG images.\nImages::make('img\/foo.jpg')-&gt;quality(60);\n\nApplying Effects\nUse the following methods to apply effects to images.\n\n\nfilter()\n\n\npixelate()\n\n\nrotate()\n\n\nblur()\n\n\nDrawing\nUse the following methods to draw on images.\n\n\ntext()\n\n\npixel()\n\n\nline()\n\n\nrectangle()\n\n\ncircle()\n\n\nellipse()\n\n\nMacros\nMacros are a basic method of extending the Streams platform.\nDefining Macros\nYou can define macros in a service provider.\nuse Streams\\Core\\Image\\Image;\n\nImage::macro('thumbnail', function () {\n    return $this-&gt;fit(148)-&gt;encode('jpg', 50);\n});\n\nApplying Macros\n$thumbnail = Images::make('img\/foo.jpg')-&gt;thumbnail();\n\nOutputting Images\nUse output methods to display image data from an image object. The img method is used by default.\nimg()\nUse the img method to return an &lt;img&gt; tag.\n{!! Images::make('img\/foo.jpg') !!}\n\nThe first parameter can be an alt tag or array of attributes. If an alt tag is provided, the attributes can still be provided as a second parameter. Note this is the default output method when used in Blade.\nImages::make('img\/foo.jpg')-&gt;img('Foo Bar Image', ['width' =&gt; '100'])\n\nNote that unmatched methods will pass through to set attribute values.\nImages::make('img\/foo.jpg')-&gt;width(100)-&gt;img('Foo Bar Image')\n\nurl()\nUse the url method to output a URL to the image. The first argument may be an array of query string parameters to append. The second argument can be used to force secure URLs. If not specified, the URLs will use the protocol of the request. If\nImages::make('img\/foo.jpg')-&gt;url()\n\n\/\/ Append a manual version query parameter.\nImages::make('img\/foo.jpg')-&gt;url(['version' =&gt; 'v1'])\n\ninline()\nUse the inline method to return an &lt;img&gt; tag with a base64 encoded src.\n{!! Images::inline('img\/foo.jpg') !!}\n\nThe first parameter can be an alt tag or array of attributes. If an alt tag is provided, the attributes can still be provided as a second parameter. Note this is the default output method when used in Blade.\nImages::make('img\/foo.jpg')-&gt;inline('Foo Bar')\n\nbase64()\nUse the base64 method to return a base64 encoded string.\n&lt;img src=&quot;{!! Images::make('img\/foo.jpg')-&gt;base64() !!}&quot;&gt;\n\ncss()\nUse the css method to return a url() string for use in CSS backgrounds.\n&lt;div style=&quot;background: {!! Images::make('img\/foo.jpg')-&gt;css() !!};&quot;&gt;\n\ndata()\nThe data method will return the contents of the image as a string.\necho Images::make('img\/foo.jpg')-&gt;data()\n\nResponsive Images\nsrcsets()\nImages::make('img\/foo.jpg')\n    -&gt;srcsets([\n        '1x' =&gt; [\n            'resize'  =&gt; 400,\n            'quality' =&gt; 60\n        ],\n        '2x' =&gt; [\n            'resize'  =&gt; 800,\n            'quality' =&gt; 90\n        ],\n        '640w' =&gt; [\n            'resize'  =&gt; 800,\n            'quality' =&gt; 90\n        ]\n    ]);\n\nsrcset()\nImages::make('img\/foo.jpg')\n    -&gt;srcset([\n        '(min-width: 600px) 400px' =&gt; [\n            'intrinsic' =&gt; 400,\n            'resize' =&gt; 400,\n            'quality' =&gt; 60\n        ],\n        '(min-width: 1600px) 800px' =&gt; [\n            'intrinsic' =&gt; 800,\n            'resize' =&gt; 800,\n            'quality' =&gt; 90\n        ]\n    ])-&gt;img();\n\npicture()\nImages::make('img\/foo.jpg')\n    -&gt;resize(1800) \/\/ Fallback\n    -&gt;picture([\n        '(min-width: 600px)' =&gt; [\n            'resize'  =&gt; 400,\n            'quality' =&gt; 60\n        ],\n        '(min-width: 1600px)' =&gt; [\n            'resize'  =&gt; 800,\n            'quality' =&gt; 90\n        ]\n    ]);\n\n","href":"\/docs\/core\/images"},{"id":"installation","title":"Installation","category":"getting_started","intro":null,"enabled":true,"body":"Downloading\nThis package is added to existing Laravel projects as a dependency by requiring it with Composer.\ncomposer require streams\/core:2.0.x-dev\n\nCloning with Git\ngit clone git@github.com:laravel-streams\/streams-core.git\n\nUpdating\nFrom within your project, use Composer to update this individual package:\ncomposer update streams\/core --with-dependencies\n\nYou can also update your entire project using composer update.\n","href":"\/docs\/core\/installation"},{"id":"integer","title":"Integer Type","link_title":"Integer","intro":"Store integer values.","category":"field_types","stage":"drafting","enabled":true,"body":"Overview\nThe integer field type stores whole number values.\n\/\/ streams\/example.json\n&quot;fields&quot;: {\n    &quot;count&quot;: {\n        &quot;type&quot;: &quot;integer&quot;\n    }\n}\n\nData Structure\n{\n    &quot;count&quot;: 100\n}\n\nBasic value access displays the stored value:\n\/\/ Basic access\n{{ $entry-&gt;count }}\n\nDecorator Usage\nBoolean types also provide decorated values.\n\/\/ Decorated value\n@if ($entry-&gt;count()-&gt;isEven())\n    \/\/ ...\n@endif\n\nMethods\n@todo Generate methods from @docs\nConfiguration\n@todo Generate config options from class::configuration\n\/\/ streams\/example.json\n&quot;fields&quot;: {\n    &quot;count&quot;: {\n        &quot;type&quot;: &quot;integer&quot;,\n        &quot;config&quot;: {\n            &quot;default&quot;: &quot;increment&quot;\n        }\n    }\n}\n\n","href":"\/docs\/core\/integer"},{"id":"introduction","title":"Streams Core","link_title":"Introduction","intro":"Streams Core is the foundation of the Streams platform.","stage":"drafting","enabled":true,"sort":1,"body":"Introduction\nStreams Core provides the most fundamental features offered by the Streams platform. It is the only required dependency which the rest of the system addons build upon.\nData First\nIt is good to approach Laravel Streams from the entry point of the streams your project needs.\n\n\nStreams\n\n\nApplication Support\nStreams Core helps you take Laravel further and in less time.\n\n\nViews\n\n\nRouting\n\n\nSecurity\n\n\nFrontend Support\nStreams Core provides frontend support that encourages and supports best-practices.\n\n\nAssets\n\n\nImages\n\n\nDeveloper Support\nThese juicy tools are specifically for developers.\n\n\n\nAddons\n\n\nApplications\n\n\nExtending Laravel Streams\n\n\nData Modeling\nData modeling is the fundamental function of Streams Core.\n\n\nStreams\n\n\nEntries\n\n\nFields\n\n\nValidation\n\n\n","href":"\/docs\/core\/introduction"},{"id":"markdown","title":"Markdown Type","link_title":"Markdown","intro":"Store [markdown](https:\/\/commonmark.org\/help\/) formatted text.","category":"field_types","stage":"drafting","enabled":true,"body":"Overview\nThe markdown field type stores markdown formatted text.\n\/\/ streams\/example.json\n&quot;fields&quot;: {\n    &quot;content&quot;: {\n        &quot;type&quot;: &quot;markdown&quot;\n    }\n}\n\nData Structure\n{\n    &quot;content&quot;: &quot;An **example** string.&quot;\n}\n\nBasic value access displays the unparsed value:\n\/\/ Basic access\n{{ $entry-&gt;content }}\n\n\nDecorator Usage\nTo get anything out of your stored value you will need to expand it.\n\/\/ Parsed value\n{{ $entry-&gt;content()-&gt;parse() }}\n\n\/\/ Parsed and rendered value\n{{ $entry-&gt;content()-&gt;render($payload) }}\n\n\nMethods\n@todo Generate methods from @docs\nConfiguration\n@todo Generate config options from class::configuration\n","href":"\/docs\/core\/markdown"},{"id":"messages","title":"Messages","category":"basics","intro":"Essential flash messages.","enabled":true,"sort":20,"body":"Introduction\nThe Streams platform provides an implementation agnostic service to include messages with the application response.\nFlash Messages\nMessages will display once, and on the next page load. This is used for view responses.\nAPI Messages\nMessages can provide standardized API errors.\nBasic Usage\nWithin your code, before the response is generated, make a call to the Messages facade.\nuse Streams\\Core\\Support\\Facades\\Messages;\n\npublic function example()\n{\n    Messages::success('Welcome aboard!');\n\n    return home();\n}\n\nError Types\nYou may also perform:\nMessages::success(): \/\/ Set the flash theme to &quot;success&quot;.\nMessages::error(): \/\/ Set the flash theme to &quot;danger&quot;.\nMessages::warning(): \/\/ Set the flash theme to &quot;warning&quot;.\nMessages::overlay(): \/\/ Render the message as an overlay.\nMessages::overlay([\n    'title' =&gt; 'Modal Title'\n    'message' =&gt; 'Modal Message',\n]): \/\/ Display a modal overlay with a title.\nMessages::danger(): \/\/ Render a &quot;danger&quot; flash message that must be dismissed.\nMessages::important(): \/\/ Add a close button to the flash message.\n\nDisplaying Messages\nWith this message flashed, you may now display it in your views. Because messages and overlays are so common, we provide a template out of the box to get you started. You're free to use - and even modify to your needs - this template how you see fit.\n@include('streams::messages')\n\nCustom Markup\nAny array data passed in, including the two mandatory type and content values.\n&lt;ul&gt;\n@foreach (Messages::pull() as $message)\n    &lt;li&gt;{{ $message-&gt;type }}: {{ $message-&gt;content }}&lt;\/li&gt;\n@endforeach\n&lt;\/ul&gt;\n\n","href":"\/docs\/core\/messages"},{"id":"multiselect","title":"Multiselect Type","link_title":"Multiselect","intro":"Store multiple enumerated values.","category":"field_types","stage":"drafting","enabled":true,"body":"Overview\nThe multiselect field type stores an array of selections from a list of options. The multiselect field type also supports callable options.\n\/\/ streams\/users.json\n&quot;fields&quot;: {\n    &quot;picks&quot;: {\n        &quot;type&quot;: &quot;multiselect&quot;,\n        &quot;config&quot;: {\n            &quot;options&quot;: {\n                &quot;star&quot;: &quot;Star&quot;,\n                &quot;circle&quot;: &quot;Circle&quot;,\n                &quot;umbrella&quot;: &quot;Umbrella&quot;,\n                &quot;triangle&quot;: &quot;Triangle&quot;\n            }\n        }\n    }\n}\n\nCallable Options\nBesides basic array and associated arrays, you may specify a callable string:\n{\n    &quot;type&quot;: &quot;multiselect&quot;,\n    &quot;config&quot;: {\n        &quot;options&quot;: &quot;\\\\App\\\\CustomOptions@handle&quot;\n    }\n}\n\nThe $type can be injected in order aid in returning options:\n\/\/ app\/CustomOptions.php\nclass CustomOptions\n{\n    public function handle($type)\n    {\n        return [\n            'foo' =&gt; 'Foo',\n            'bar' =&gt; 'Bar',\n        ];\n    }\n}\n\nData Structure\n{\n    &quot;picks&quot;: [&quot;circle&quot;, &quot;triangle&quot;]\n}\n\nBasic value access displays the stored key value:\n\/\/ Basic access\n[{{ implode(', ', $entry-&gt;picks) }}]\n\nDecorator Usage\nMultiselect types also provide decorated values.\n\/\/ Decorated value\n[{{ implode(',' $entry-&gt;picks()-&gt;values()) }}]\n\nMethods\n@todo Generate methods from @docs\nConfiguration\n@todo Generate config options from class::configuration\n","href":"\/docs\/core\/multiselect"},{"id":"number","title":"Number Type","link_title":"Number","intro":"Store numeric values.","category":"field_types","stage":"drafting","enabled":true,"body":"Overview\nThe number field type stores numeric values including floating point numbers. If you need to support fixed-precision numbers, check out the decimal field type.\n\/\/ streams\/example.json\n&quot;fields&quot;: {\n    &quot;price&quot;: {\n        &quot;type&quot;: &quot;number&quot;\n    }\n}\n\nConfiguration\n@todo Generate config options from class::configuration\nData Structure\n{\n    &quot;price&quot;: 89.95\n}\n\nBasic value access displays the stored value:\n\/\/ Basic access\n{{ $entry-&gt;price }}\n\nDecorator Usage\nBoolean types also provide decorated values.\n\/\/ Decorated value\n@if ($entry-&gt;price()-&gt;isOdd())\n    \/\/ ...\n@endif\n\nMethods\n@todo Generate methods from @docs\n","href":"\/docs\/core\/number"},{"id":"object","title":"Object Type","link_title":"Object","category":"field_types","intro":"The `object` field type stores structured `key:value` data.","stage":"drafting","enabled":true,"body":"Overview\nThe object field type is used for storing objects. Objects can be simple or complex types. By default, any type is valid.\n\/\/ streams\/example.json\n&quot;fields&quot;: {\n    &quot;address&quot;: {\n        &quot;type&quot;: &quot;object&quot;\n    }\n}\n\nData Structure\n{\n    &quot;address&quot;: {\n        &quot;street&quot;: &quot;3159 W 11th St&quot;,\n        &quot;city&quot;: &quot;Cleveland&quot;,\n        &quot;state&quot;: &quot;OH&quot;\n    }\n}\n\nBasic object access:\n\/\/ Array access\n{{ $entry-&gt;address-&gt;street }}\n\n\nDecorator Usage\nThe decorated value provides an object as well.\n\/\/ Decorated value\n{{ $entry-&gt;address-&gt;street }}\n\n\nMethods\n@todo Generate methods from @docs\nConfiguration\n@todo Generate config options from class::configuration\nSchemas\nUse the sdchemas configuration to specify the allowed types. If specified, each item must be valid against one of the provided types.\n\/\/ streams\/example.json\n&quot;fields&quot;: {\n    &quot;items&quot;: {\n        &quot;type&quot;: &quot;object&quot;,\n        &quot;config&quot;: {\n            &quot;schemas&quot;: [\n                { &quot;stream&quot;: &quot;addresses&quot; },\n                { &quot;abstract&quot;: &quot;App\\\\Support\\\\Address&quot; }\n            ]\n        }\n    }\n}\n\n","href":"\/docs\/core\/object"},{"id":"parser","title":"Parsing Variables","category":"developers","enabled":true,"sort":90,"body":"Introduction\nStreams parses variables within strings to allow dynamic configuration.\nRequest Variables\nThe following request variables are available:\n'request' =&gt; [\n    'url'      =&gt; Request::url(),\n    'path'     =&gt; Request::path(),\n    'root'     =&gt; Request::root(),\n    'input'    =&gt; Request::input(),\n    'full_url' =&gt; Request::fullUrl(),\n    'segments' =&gt; Request::segments(),\n    'uri'      =&gt; Request::getRequestUri(),\n    'query'    =&gt; Request::getQueryString(),\n    'parsed'   =&gt; array_merge($parsed, [\n        'domain' =&gt; explode('.', $parsed['host'])\n    ]),\n],\n\nURL Variables\nThe following URL variables are available:\n'url' =&gt; [\n    'previous' =&gt; URL::previous(),\n],\n\nRoute Variables\nThe following route variables are available:\n'route' =&gt; [\n    'uri'                      =&gt; Request::route()-&gt;uri(),\n    'parameters'               =&gt; Request::route()-&gt;parameters(),\n    'parameters.to_urlencoded' =&gt; array_map(\n        function ($parameter) {\n            return urlencode($parameter);\n        },\n        array_filter(Request::route()-&gt;parameters())\n    ),\n    'parameter_names'          =&gt; Request::route()-&gt;parameterNames(),\n    'compiled'                 =&gt; [\n        'static_prefix'     =&gt; Request::route()-&gt;getCompiled()-&gt;getStaticPrefix(),\n        'parameters_suffix' =&gt; str_replace(\n            Request::route()-&gt;getCompiled()-&gt;getStaticPrefix(),\n            '',\n            Request::getRequestUri()\n        ),\n    ],\n],\n\n@todo clean up and use table\/values.\n","href":"\/docs\/core\/parser"},{"id":"querying","title":"Criteria","link_title":"Querying","category":"database","intro":"An extensible, fast, and database-indifferent querying API.","stage":"outlining","enabled":true,"sort":9,"body":"Introduction\nQuerying builds upon knowledge of streams, fields, and entries. Using the querying techniques below you can retreive, insert, and update stream configured entry data.\nGetting Started\nTo initialize a new query use the Streams::entries() method.\nuse Streams\\Core\\Support\\Facades\\Streams;\n\n$query = Streams::entries('contacts');\n\nThe Basics\nYou can chain the below methods together to build query logic and return a collection of results.\nuse Streams\\Core\\Support\\Facades\\Streams;\n\n$results = Streams::entries('contacts')\n    -&gt;where('email', 'like', '%@gmail.com')\n    -&gt;orderBy('name', 'asc')\n    -&gt;get();\n\nFiltering\nBasic Where Clauses\nYou may use the where method on a query instance to add where clauses to the query. The most basic call to where requires three arguments. The first argument is the handle of the field. The second argument is an operator, which can be any of the database's supported operators including IN and NOT IN. Finally, the third argument is the value to evaluate against the field value.\nFor example, here is a query that verifies the value of the &quot;votes&quot; column is equal to 100:\n$users = Streams::entries('users')-&gt;where('votes', '=', 100)-&gt;get();\n\nFor convenience, if you want to verify that a field is equal to a given value, you may pass the value directly as the second argument to the where method:\n$users = Streams::entries('users')-&gt;where('votes', 100)-&gt;get();\n\nYou may use a variety of other operators when writing a where clause:\n$users = Streams::entries('users')\n    -&gt;where('votes', '&gt;=', 100)\n    -&gt;get();\n\n$users = Streams::entries('users')\n    -&gt;where('votes', '&lt;&gt;', 100)\n    -&gt;get();\n\n$users = Streams::entries('users')\n    -&gt;where('name', 'like', 'T%')\n    -&gt;get();\n\nOr Statements\nYou may chain where constraints together as well as add or clauses to the query. The orWhere method accepts the same arguments as the where method:\n$users = Streams::entries('users')\n    -&gt;where('votes', '&gt;', 100)\n    -&gt;orWhere('name', 'John')\n    -&gt;get();\n\nSorting\/Ordering\nThe orderBy method allows you to sort the result of the query by a given field. The first argument to the orderBy method should be the field you wish to sort by, while the second argument controls the direction of the sort and may be either asc or desc:\n$users = Streams::entries('users')\n    -&gt;orderBy('name', 'desc')\n    -&gt;get();\n\nIf you need to sort by multiple fields, you may invoke orderBy as many times as needed:\n$users = Streams::entries('users')\n    -&gt;orderBy('name', 'desc')\n    -&gt;orderBy('email', 'asc')\n    -&gt;get();\n\nLimit\/Offset\nThe limit method allows you to limit the number of result returned by the query and an offset value. The first argument to the limit method should be the number of entries you wish to return, while the second argument controls the offset of the query, if any:\n\/\/ The first 10\n$users = Streams::entries('users')\n    -&gt;limit(10)\n    -&gt;get();\n\n\/\/ The next 10\n$users = Streams::entries('users')\n    -&gt;limit(10, 10)\n    -&gt;get();\n\nPagination\nThe paginate method allows you to generate a paginated result. A Laravel paginator instance is returned.\n$users = Streams::entries('users')-&gt;paginate(15);\n\necho $users-&gt;links(); \/\/ Render pagination\necho $users-&gt;items(); \/\/ Return all items\necho $users-&gt;total(); \/\/ Return total items\n\nChunk\nThe chunk method allows you to chunk through large datasets without exhausting memory.\nStreams::entries('users')-&gt;chunk(1000, function ($users) {\n    $users-&gt;each(function ($user) {\n        echo $user-&gt;email;\n    });\n});\n\nCaching\nThe cache method allows you to cache query results. The first parameter should be the seconds in which to cache the results. An optional second parameter can be provided as a key, otherwise one will be generated based on your query fingerprint.\n$favorites = Streams::entries('books')\n    -&gt;where('favorited', true)\n    -&gt;cache(600, 'favorites')\n    -&gt;get();\n\nFor more information on managing cache please see the cache documentation.\nExtending Queries\nThere are numerous techniques you can use to extend querying logic.\nExtending Basics\nThe query object is macroable.\n\n\nExtending the Streams Platform\n\n\nQuery Criteria\nThe criteria interface serves as the wrapper for various query building logic.\n","href":"\/docs\/core\/querying"},{"id":"relationship","title":"Relationship Type","link_title":"Relationship","intro":"Relate to any stream entry.","category":"field_types","stage":"drafting","enabled":true,"body":"Overview\nA single relationship to a stream entry.\n\/\/ streams\/users.json\n&quot;fields&quot;: {\n    &quot;user&quot;: {\n        &quot;type&quot;: &quot;relationship&quot;,\n        &quot;config&quot;: {\n            &quot;related&quot;: &quot;users&quot;\n        }\n    }\n}\n\nData Structure\n{\n    &quot;user&quot;: &quot;655de760-6ba0-3f4f-ad0c-8051588ad6e2&quot;\n}\n\nBasic value access displays the entry instance:\n\/\/ Basic access\n{{ $entry-&gt;user-&gt;email }}\n\nDecorator Usage\nThe decorated value also provides the same instance.\n\/\/ Decorated value\n{{ $entry-&gt;user()-&gt;email }}\n{!! $entry-&gt;user()-&gt;email()-&gt;mailto() !!}\n\nMethods\n@todo Generate methods from @docs\nConfiguration\n@todo Generate config options from class::configuration\n\/\/ streams\/users.json\n&quot;fields&quot;: {\n    &quot;user&quot;: {\n        &quot;type&quot;: &quot;relationship&quot;,\n        &quot;config&quot;: {\n            &quot;related&quot;: &quot;users&quot;\n        }\n    }\n}\n\n","href":"\/docs\/core\/relationship"},{"id":"repositories","title":"Repositories","category":"database","intro":null,"stage":"outlining","enabled":true,"sort":10,"body":"Introduction\nThe Streams platform separates methods to retrieve and store entries from the entry objects themselves via repositories.\nGetting Started\nYou can initialize an entry repository using the Streams::repository() method and specifying the stream.\nuse Streams\\Core\\Support\\Facades\\Streams;\n\n\/\/ Start using the repository.\nStreams::repository('contacts');\n\n\/\/ You can also access from the stream.\nStreams::make('contacts')-&gt;repository();\n\nNew Queries\nNew queries can be started from the repository.\n\/\/ Start a new query.\nStreams::entries('contacts');\n\n\/\/ You can also start queries from the repository.\nStreams::repository('contacts')-&gt;newQuery();\n\nThe Basics\nInserting Entries\nUpdating Entries\nDeleting Entries\nExtending Repositories\nExtending Basics\nCustom Repositories\n","href":"\/docs\/core\/repositories"},{"id":"routing","title":"Routing","category":"basics","intro":null,"sort":10,"stage":"reviewing","enabled":true,"todo":["Allow configuring view resolution patterns using tags (resources\/{stream}.blade.php, resources\/{singular}.blade.php, resources\/{stream}\/{action}.blade.php)"],"body":"Introduction\nAll requests to your application are handled by Laravel unless you create the routes using one of the specific methods described below.\nDefining Routes\nThe Streams platform has a couple of ways it routes requests, which are listed below. Otherwise, standard Laravel routing applies.\nRoute Files\nYou can configure routes just as you would in a regular Laravel application using the routes\/web.php file.\nStreams Router\nThe Streams platform provides a Route::streams() method for defining routes. All streams-specific routing approaches pass through this method.\n\/\/ Options\nRoute::streams('uri', [\n    'foo' =&gt; 'bar',\n]);\n\n\/\/ View\nRoute::streams('uri', 'view');\n\n\/\/ Controller\nRoute::streams('uri', 'App\\Http\\Controller\\Example@show');\n\n\/\/ Controller and more\nRoute::streams('uri', [\n    'uses' =&gt; 'App\\Http\\Controller\\Example@show'\n]);\n\nThe first argument is the URI and the second is either:\n\nThe name of the view to render.\nA callable string.\nAn array of route options.\n\nStream Routes\nDefining routes in your stream configuration makes it easy to automate naming and URL generation around your domain information and entities.\nDefine stream routes using a action =&gt; options format, where options is again either the URI, controller and method string, or an array of route options.\n\/\/ streams\/contacts.json\n{\n    &quot;routes&quot;: {\n        &quot;index&quot;: {\n            &quot;uri&quot;: &quot;contacts&quot;,\n            &quot;view&quot;: &quot;contacts&quot;\n        },\n        &quot;view&quot;: {\n            &quot;uri&quot;: &quot;contacts\/{id}&quot;,\n            &quot;view&quot;: &quot;contact&quot;\n        },\n        &quot;profile&quot;: {\n            &quot;uri&quot;: &quot;contacts\/{id}&quot;,\n            &quot;view&quot;: &quot;profile&quot;\n        }\n    }\n}\n\nAutomatic Naming\nUnless a route name is specified, stream configured routes automatically name themselves like streams::{stream}.{action}.\n$url = route('streams::contacts.index');\n\nAutomatically Resolved Views\nUnless a view is specified, the associated requests will attempt to resolve a view automatically.\n\/\/ streams\/contacts.json\n{\n    &quot;routes&quot;: {\n        &quot;index&quot;: {\n            &quot;uri&quot;: &quot;contacts&quot;\n            \/\/ resources\/contacts\/index.php\n        },\n        &quot;view&quot;: {\n            &quot;uri&quot;: &quot;contacts\/{id}&quot;\n            \/\/ resources\/contacts\/view.php\n        },\n        &quot;rss&quot;: {\n            &quot;uri&quot;: &quot;contacts\/{id}\/rss&quot;\n            \/\/ resources\/contacts\/rss.php\n        }\n    }\n}\n\nYou can configure automatic view patterns within the streams\/route.php configuration file. The process ignores the views if they do not exist.\nRoute Parameters\nThe Streams platform adds support for deep parameter variables using a dot notation when using the URL::streams() method to generate URLs.\nURL::streams('uri\/{foo.bar}', 'view');\n\nStream Parameter\nYou can specify the stream associated with the route using the route option or by using the {stream} URI segment variable in your URI pattern to resolve the stream by its handle.\nRoute::streams('address-book\/{stream}', 'contacts');\n\nConsider locking down this routing pattern using a parameter constraint.\nRoute::streams('address-book\/{stream}', [\n    'view' =&gt; 'contacts.list',\n    'constraints' =&gt; [\n        'stream' =&gt;  '(businesses|family)'\n    ],\n]);\n\nThe resolved stream will be available within the view:\n&lt;h1&gt;{{ $stream-&gt;name }}&lt;\/h1&gt;\n\n&lt;ul&gt;\n    @foreach ($stream-&gt;entries()-&gt;get() as $entry)\n    &lt;li&gt;{{ $entry-&gt;name }}&lt;\/li&gt;\n    @endforeach\n&lt;\/ul&gt;\n\nEntry Parameters\nYou can specify a stream entry associated with the route using the route option or by using the {id} URI segment variable in your URI pattern to resolve the entry by its ID or handle.\nRoute::streams('address-book\/{stream}\/{id}', 'contacts');\n\nYou can also use {entry.*} parameters to query the entry by its field values.\n\/\/ address-book\/contacts\/ryan@example.com\nRoute::streams('address-book\/{stream}\/{entry.email}', 'contacts');\n\nThe first matching entry will be available within the view:\n&lt;h1&gt;{{ $entry-&gt;name }}&lt;\/h1&gt;\n\nA 404 error page will be displayed entry resolution is attempted, but no entry is found.\nRoute Options\nAll Streams platform-specific methods of registering routes support the following route options.\nAll route options are parsed with controller data:\nRoute::streams('address-book\/{stream}\/{id}', [\n    'view' =&gt; '{streams.handle}',\n]);\n\nView\nUse the view option to specify a view to render:\nRoute::streams('uri', [\n    'foo' =&gt; 'bar',\n    'view' =&gt; 'example',\n]);\n\nStream\nUse the stream option to specify the stream associated with the request. Stream configured routes will do this automatically.\nRoute::streams('uri', [\n    'stream' =&gt; 'contacts',\n]);\n\nThe stream is automatically injected into the view:\n&lt;h1&gt;{{ $stream-&gt;name }}&lt;\/h1&gt;\n\n&lt;ul&gt;\n    @foreach ($stream-&gt;entries()-&gt;get() as $entry)\n    &lt;li&gt;{{ $entry-&gt;name }}&lt;\/li&gt;\n    @endforeach\n&lt;\/ul&gt;\n\nEntry\nYou can also specify a specific entry identifier:\nRoute::streams('uri', [\n    'stream' =&gt; 'contacts',\n    'entry' =&gt; 'john_smith',\n]);\n\nThe stream entry is automatically injected into the view:\n\/\/ uri\/ryan_thompson\n&lt;h1&gt;{{ $entry-&gt;name }}&lt;\/h1&gt;\n\nYou can use entry fields to query entries for the view.\n\/\/ uri\/ryan@example.com\nRoute::streams('uri\/{entry.email}', [\n    'stream' =&gt; 'contacts',\n]);\n\nYou can also hard code the entry ID or handle:\nRoute::streams('uri', [\n    'stream' =&gt; 'contacts',\n    'entry' =&gt; 'ryan_thompson',\n]);\n\nThe first result is automatically injected into the view:\n\/\/ uri\/ryan_thompson\n&lt;h1&gt;{{ $entry-&gt;name }}&lt;\/h1&gt;\n\nRedirect\nUse the redirect and optional status_code option to specify a redirect:\nRoute::streams('uri\/{entry.name}', [\n    'redirect' =&gt; '\/new\/uri',\n    'status_code' =&gt; 301, \/\/ Default\n]);\n\nRedirects highlight a good use case to leverage the fact that route options are parsed with controller data:\nRoute::streams('uri\/{entry.name}', [\n    'redirect' =&gt; '\/new\/uri\/{stream.id}\/{entry.name}',\n    'status_code' =&gt; 301, \/\/ Default\n]);\n\nNative Redirects\nYou can create Laravel redirects in your routes\/web.php using the Route facade as well:\nRoute::redirect('\/from', '\/to');\nRoute::redirect('\/from', '\/to', 301);\nRoute::permanentRedirect('\/from', '\/to');\n\nNamed Routes\nUse the as option to specify the name of the route:\nRoute::streams('uri', [\n    'view' =&gt; 'example',\n    'as' =&gt; 'login',\n]);\n\nYou can refer to the route by name using the typical Laravel methods:\n$url = route('login');\n\nHTTP Verbs\nUse the verb option to specify the HTTP verb the route should respond to:\nRoute::streams('uri', ['verb' =&gt; 'any']);\nRoute::streams('uri', ['verb' =&gt; 'get']); \/\/ Default\nRoute::streams('uri', ['verb' =&gt; 'put']);\nRoute::streams('uri', ['verb' =&gt; 'post']);\nRoute::streams('uri', ['verb' =&gt; 'patch']);\nRoute::streams('uri', ['verb' =&gt; 'delete']);\nRoute::streams('uri', ['verb' =&gt; 'options']);\n\nRoute Middleware\nUse the middleware option to assign additional middleware to the route:\nRoute::streams('uri', [\n    'middleware' =&gt; ['first', 'second']\n]);\n\nParameter Constraints\nUse the constraints option to specify allowed parameter formatting for the route using regular expression:\nRoute::streams('uri\/{name}', [\n    'constraints' =&gt; ['name' =&gt; '[A-Za-z]+']\n]);\n\nLaravel does not support dots in parameter names at this time. For this reason, {entry.name} type parameters transform into {entry__name}.\nRoute::streams('uri\/{entry.name}', [\n    'constraints' =&gt; ['entry__name' =&gt; '[A-Za-z]+']\n]);\n\nDisabling CSRF\nYou can disable CSRF protection using the csrf option.\nRoute::streams('uri', [\n    'csrf' =&gt; false\n]);\n\nDeferring Routes\nUse the defer option to defer registering a route.\nRoute::streams('\/{id}', [\n    \/\/ ...\n    'defer' =&gt; true,\n]);\n\nGenerating URLs\nYou may use the URL::streams() method to generate URLs for named routes, including those with dotted parameter variables. This method also supports parsing URL strings with parameter data. The extra data argument is appending as a query string. Use the absolute argument to control whether the resulting URL is absolute or not.\nURL::streams($target, $parameters = [], $extra = [], $absolute = true);\n\n$entry = Streams::entries('contacts')-&gt;first();\n\n\/\/ contacts\/{entry.email}\/{entry.id}\n$url = URL::streams('streams::contacts.view', ['entry' =&gt; $entry]);\n\n\/\/ contacts\/{email}\/{id}\n$url = URL::streams('streams::contacts.view', $entry);\n\nYou can also use Laravel URL generation for named routes, though dotted parameters are not supported using Laravel methods:\n\/\/ Generating URLs.\n$url = route('streams::contacts.index');\n\n\/\/ Generating Redirects.\nreturn redirect()-&gt;route('streams::contacts.index');\n\nError Pages\nErrors render views based on the status code of the error. For example, a 404 error will look a view in resources\/views\/errors\/{status_code}.blade.php.\nLaravel will automatically render a 404 page for any unhandled routes.\n\n\nLaravel Custom Error Pages\n\n\n","href":"\/docs\/core\/routing"},{"id":"security","title":"Security","category":"basics","intro":null,"stage":"outlining","enabled":true,"sort":99,"todo":null,"body":"CSRF\nThe Streams platform build on Laravel CSRF basics.\nRoute Option\nYou can also disable CSRF protection using route options.\n&quot;csrf&quot;: false\n\nRoute::streams('uri', [\n    'csrf' =&gt; false\n]);\n\nPolicies\nThe Streams platform uses policies to authorize secured actions.\nUsers\nThe Streams platform makes it easy to use and integrate any authentication system or roll your own based on your projects needs.\nResources\n\n\n@todo Example Users\n\n\n","href":"\/docs\/core\/security"},{"id":"select","title":"Select Type","link_title":"Select","intro":"Store enumerated values.","category":"field_types","stage":"drafting","enabled":true,"body":"Overview\nThe select field type stores a selection from a list of options.\n\/\/ streams\/users.json\n&quot;fields&quot;: {\n    &quot;status&quot;: {\n        &quot;type&quot;: &quot;select&quot;,\n        &quot;config&quot;: {\n            &quot;options&quot;: {\n                &quot;enabled&quot;: &quot;Enabled&quot;,\n                &quot;pending&quot;: &quot;Pending&quot;,\n                &quot;disabled&quot;: &quot;Disabled&quot;\n            },\n            &quot;default&quot;: &quot;pending&quot;\n        }\n    }\n}\n\nCallable Options\nBesides basic array and associated arrays, you may specify an invokable class:\n{\n    &quot;type&quot;: &quot;select&quot;,\n    &quot;config&quot;: {\n        &quot;options&quot;: &quot;\\\\App\\\\InvokableOptions&quot;\n    }\n}\n\nOr, callable class and method:\n{\n    &quot;type&quot;: &quot;select&quot;,\n    &quot;config&quot;: {\n        &quot;options&quot;: &quot;\\\\App\\\\CustomOptions@handle&quot;\n    }\n}\n\nThe $type can be injected in order aid in returning options:\n\/\/ app\/InvokableOptions.php\nclass InvokableOptions\n{\n    public function __invoke($type)\n    {\n        return [\n            'foo' =&gt; 'Bar',\n        ];\n    }\n}\n\n\/\/ app\/CustomOptions.php\nclass CustomOptions\n{\n    public function handle($type)\n    {\n        return [\n            'foo' =&gt; 'Bar',\n        ];\n    }\n}\n\nData Structure\n{\n    &quot;status&quot;: &quot;enabled&quot;\n}\n\nBasic value access displays the stored key value:\n\/\/ Basic access\n{{ $entry-&gt;status }}\n\nDecorator Usage\nSelect types also provide decorated values.\n\/\/ Decorated value\nStatus: {{ $entry-&gt;status()-&gt;value() }}\n\nMethods\n@todo Generate methods from @docs\nConfiguration\n@todo Generate config options from class::configuration\n","href":"\/docs\/core\/select"},{"id":"slug","title":"Slug Type","link_title":"Slug","category":"field_types","intro":"The `slug` field type stores `key:value` slug data.","stage":"drafting","enabled":true,"body":"Overview\nThe slug field type is used for storing indexed arrays. Items can be simple or complex types. By default, any item type is valid.\n\/\/ streams\/example.json\n&quot;fields&quot;: {\n    &quot;id&quot;: {\n        &quot;type&quot;: &quot;slug&quot;\n    }\n}\n\nData Structure\n{\n    &quot;id&quot;: &quot;john-doe&quot;\n}\n\nMethods\n@todo Generate methods from @docs\nConfiguration\n@todo Generate config options from class::configuration\n","href":"\/docs\/core\/slug"},{"id":"sources","title":"Sources","category":"database","intro":"Source adapters connect streams to any source of information you might encounter.","enabled":true,"sort":0,"body":"Introduction\nSource adapters helps you query any source of data you might encounter in the wild.\nDefining Sources\nSpecify source information in your stream configuration.\nIf no source is specified, the below defaults will be assumed.\n\/\/ streams\/{handle}.json\n{\n    &quot;config&quot;: {\n        &quot;source&quot;: {\n            &quot;format&quot;: &quot;json&quot;,\n            &quot;type&quot;: &quot;filebase&quot;,\n            &quot;path&quot;: &quot;streams\/data\/{handle}&quot;\n        }\n    }\n}\n\nAvailable Sources\nThe following sources are available with the Streams platform by default.\nSelf\nYou can define data within on your stream configuration file.\n\/\/ streams\/contacts.json\n{\n    &quot;config&quot;: {\n        &quot;source&quot;: {\n            &quot;type&quot;: &quot;self&quot;\n        }\n    },\n    &quot;data&quot;: {\n        &quot;john&quot;: {\n            &quot;name&quot;: &quot;John Doe&quot;\n        },\n        &quot;jane&quot;: {\n            &quot;name&quot;: &quot;Jane Doe&quot;\n        }\n    }\n}\n\nFilebase\nThe flat file database powered by the fantastic Filebase package is the default source.\n\/\/ streams\/contacts.json\n{\n    &quot;config&quot;: {\n        &quot;source&quot;: {\n            &quot;format&quot;: &quot;json&quot;,\n            &quot;type&quot;: &quot;filebase&quot;,\n            &quot;path&quot;: &quot;streams\/data\/contacts&quot;\n        }\n    }\n}\n\nJSON Format\n\/\/ streams\/data\/contacts\/ryan.json\n{\n    &quot;name&quot;: &quot;Ryan&quot;,\n    &quot;email&quot;: &quot;ryan@example.com&quot;\n}\n\nYAML Format\n\/\/ streams\/data\/contacts\/ryan.yaml\n\n---\n\nname: &quot;Ryan&quot;\nemail: &quot;ryan@example.com&quot;\n\n---\n\nThe body is built in: {{ $entry-&gt;name }}\n\nMD Format\n\/\/ streams\/data\/contacts\/ryan.md\n\n---\n\nname: &quot;Ryan&quot;\nemail: &quot;ryan@example.com&quot;\n\n---\n\nThe body is built in: {{ $entry-&gt;name }}\n\nTPL Format\n\/\/ streams\/data\/contacts\/ryan.tpl\n\n---\n\nname: &quot;Ryan&quot;\nemail: &quot;ryan@example.com&quot;\n\n---\n\nThe body is built in: {{ $entry-&gt;name }}\n\nEloquent Model\nThe eloquent model source uses Laravel models to query and can return stream-enhanced Eloquent models.\n\/\/ streams\/contacts.json\n{\n    &quot;config&quot;: {\n        &quot;source&quot;: {\n            &quot;type&quot;: &quot;eloquent&quot;,\n            &quot;model&quot;: &quot;App\\\\Contact\\\\ContactModel&quot;\n        }\n    }\n}\n\nLaravel Database\nThe Laravel database source uses generic Laravel database tables to query and return stream entries.\n\/\/ streams\/contacts.json\n{\n    &quot;config&quot;: {\n        &quot;source&quot;: {\n            &quot;type&quot;: &quot;database&quot;,\n            &quot;table&quot;: &quot;contacts&quot;,\n            &quot;connection&quot;: &quot;default&quot;\n        }\n    }\n}\n\nExtending\nYou can create and register a custom source adapter for any source of information you might encounter.\nCustom Sources\n@todo  Talk about developing custom source adapters.\n","href":"\/docs\/core\/sources"},{"id":"streams","title":"Streams","category":"core_concepts","intro":"Code-configured domain information.","sort":1,"stage":"drafting","enabled":true,"references":["https:\/\/craftcms.com\/docs\/3.x\/elements.html","https:\/\/craftcms.com\/docs\/3.x\/element-queries.html"],"todo":["Finish streams routes"],"body":"Introduction\nThe Streams platform leans heavily on domain-driven design (DDD). We call these domain abstractions streams, hence our namesake.\nAn example could be configuring a domain model (a stream) for a website's pages, users of an application, or feedback submissions from a form. Streams describe your data structures.\nDefining Streams\nUsing JSON files, you can define stream configurations in the streams\/ directory. The filenames serve as the stream's id.\nIt is highly encouraged to use the plural form of a noun when naming Streams\u2014for example, contacts and people. Also, naming conventions like business_contacts or neat-people work well.\n\u251c\u2500\u2500 streams\/\n\u2502   \u251c\u2500\u2500 users.json\n\u2502   \u251c\u2500\u2500 pages.json\n\u2502   \u2514\u2500\u2500 contacts.json\n\nThe Basics\nTo get started, you need only specify the id, which is the filename itself, and some fields to describe the domain object's structure.\nLet's create a little stream to hold information for a simple CRM.\n\/\/ streams\/contacts.json\n{\n    &quot;name&quot;: &quot;Contacts&quot;,\n    &quot;description&quot;: &quot;A simple address book.&quot;,\n    &quot;config&quot;: {\n        &quot;source&quot;: {\n            &quot;type&quot;: &quot;filebase&quot;,\n            &quot;filename&quot;: &quot;streams\/data\/contacts&quot;,\n            &quot;format&quot;: &quot;json&quot;\n        },\n        &quot;abstract&quot;: &quot;Streams\\\\Core\\\\Entry\\\\Entry&quot;,\n        &quot;criteria&quot;: &quot;Streams\\\\Core\\\\Criteria\\\\Criteria&quot;,\n        &quot;repository&quot;: &quot;Streams\\\\Core\\\\Repository\\\\Repository&quot;,\n        &quot;collection&quot;: &quot;Illuminate\\\\Support\\\\Collection&quot;,\n    },\n    &quot;fields&quot;: {\n        &quot;name&quot;: &quot;string&quot;,\n        &quot;email&quot;: &quot;email&quot;,\n        &quot;company&quot;: {\n            &quot;type&quot;: &quot;relationship&quot;,\n            &quot;config&quot;: {\n                &quot;related&quot;: &quot;companies&quot;\n            }\n        }\n    }\n}\n\nFields\n\n\nFields\n\n\nField Types\n\n\nFields are an essential descriptor of the domain object. They describe what properties the domain object will have and how they work. Field types control things like accessors, data mutation, and casting.\nThe field configuration keys serve as a handle, which you can use to reference the field later. So, for example, you may access the above contact fields like this:\n$entry-&gt;email;\n$entry-&gt;company-&gt;email;\n\nStream Routes\n\n\nStream Routes\n\n\nRoute Options\n\n\nStreams can simplify routing by defining associated routes in their definition.\n\/\/ streams\/contacts.json\n{\n    &quot;routes&quot;: {\n        &quot;index&quot;: &quot;contacts&quot;,\n        &quot;view&quot;: &quot;contacts\/{id}&quot;\n    }\n}\n\nYou can also use an array to include other route options.\n\/\/ streams\/contacts.json\n{\n    &quot;routes&quot;: {\n        &quot;contact&quot;: {\n            &quot;csrf&quot;: false,\n            &quot;uri&quot;: &quot;form\/{entry.email}&quot;\n        }\n    }\n}\n\nStream Validation\nStreams simplifies validation by defining validation in their definition.\n\n\nDefining Rules\n\n\n\/\/ streams\/contacts.json\n{\n    &quot;rules&quot;: {\n        &quot;name&quot;: [\n            &quot;required&quot;,\n            &quot;max:100&quot;\n        ],\n        &quot;email&quot;: [\n            &quot;required&quot;,\n            &quot;email:rfc,dns&quot;\n        ],\n        &quot;company&quot;: &quot;required|unique&quot;\n    }\n}\n\nSecurity\nSpecify the Laravel policy to use for security.\n\/\/ streams\/contacts.json\n{\n    &quot;policy&quot;: &quot;App\\\\Contacts\\\\ContactPolicy&quot;\n}\n\nCaching\nStreams provides a touch-free caching system you can define in the configuration.\n\n\nDefining Rules\n\n\n\/\/ streams\/contacts.json\n{\n    &quot;cache&quot;: false,\n    &quot;ttl&quot;: 1800 \/\/ 30 minutes\n}\n\nSources\nSources define the source information for entry data which you can define in the configuration.\n\n\nDefining Sources\n\n\n\/\/ streams\/contacts.json\n{\n    &quot;source&quot;: {\n        &quot;type&quot;: &quot;filebase&quot;,\n        &quot;format&quot;: &quot;md&quot;\n    }\n}\n\nStream Entries\nDomain entities are called entries within the Streams platform. A stream defines entry attributes, or fields, that dictate the entry's properties, data-casting, and more.\n\n\nDefining Entries\n\n\nAbstracts\nThe abstract parameter defines the class to use when constructing entry instances.\n\n\nEntry Abstracts\n\n\n\/\/ streams\/contacts.json\n{\n    &quot;abstract&quot;: &quot;App\\\\Contacts\\\\Contact&quot;\n}\n\n\nWhen defining Elqouent stream sources, the sources model will be used as the abstract.\n\nCriteria\nThe criteria parameter defines the class to use when building entry queries.\n\n\nQuerying Entries\n\n\n\/\/ streams\/contacts.json\n{\n    &quot;criteria&quot;: &quot;App\\\\Contacts\\\\ContactCriteria&quot;\n}\n\nRepositories\nThe repository parameter defines the repository class to use for the stream entries.\n\n\nEntry Repositories\n\n\n\/\/ streams\/contacts.json\n{\n    &quot;repository&quot;: &quot;App\\\\Contacts\\\\ContactRepository&quot;\n}\n\nAdvanced Streams\nJSON References\nYou can use JSON file references within stream configurations to point to other JSON files using the @ symbol followed by a relative path to the file. In this way, you can reuse various configuration information or tidy up larger files. The referenced file's JSON data directly replaces the reference.\n\/\/ streams\/contacts.json\n{\n    &quot;name&quot;: &quot;Contacts&quot;,\n    &quot;fields&quot;: &quot;@streams\/fields\/contacts.json&quot;\n}\n\n\/\/ streams\/fields\/contacts.json\n{\n    &quot;name&quot;: &quot;string&quot;,\n    &quot;email&quot;: &quot;email&quot;,\n    &quot;company&quot;: {\n        &quot;type&quot;: &quot;relationship&quot;,\n        &quot;stream&quot;: &quot;company&quot;\n    }\n}\n\nExtend a Stream\nA stream can extend another stream, which works like a recursive merge.\n\/\/ streams\/family.json\n{\n    &quot;name&quot;: &quot;Family Members&quot;,\n    &quot;extend&quot;: &quot;contacts&quot;,\n    &quot;fields&quot;: {\n        &quot;relation&quot;: {\n            &quot;type&quot;: &quot;select&quot;,\n            &quot;config&quot;: {\n                &quot;options&quot;: {\n                    &quot;mother&quot;: &quot;Mother&quot;,\n                    &quot;father&quot;: &quot;Father&quot;,\n                    &quot;brother&quot;: &quot;Brother&quot;,\n                    &quot;sister&quot;: &quot;Sister&quot;\n                }\n            }\n        }\n    }\n}\n\nIn the above example, all contacts fields are available to you, as well as the new relation field.\n$entry-&gt;email;      \/\/ The email value.\n$entry-&gt;relation;   \/\/ The relation value.\n\nStream Sources\nYou can configure the flat-file database as well as other sources for storing data including any Laravel database. No code changes required.\n","href":"\/docs\/core\/streams"},{"id":"string","title":"String Type","link_title":"String","intro":"Store text values.","category":"field_types","stage":"drafting","enabled":true,"body":"Overview\nThe string field type stores a basic string.\n\/\/ streams\/example.json\n&quot;fields&quot;: {\n    &quot;name&quot;: {\n        &quot;type&quot;: &quot;string&quot;\n    }\n}\n\nData Structure\n{\n    &quot;name&quot;: &quot;John&quot;\n}\n\nBasic value access displays encrypted value:\n\/\/ Basic access\n{{ $entry-&gt;name }}\n\n\nDecorator Usage\nStrings also provide decorated values.\n\/\/ Decorated value\n{{ implode('; ', $entry-&gt;example()-&gt;lines()) }}\n\n\nMethods\n@todo Generate methods from @docs\nConfiguration\n@todo Generate config options from class::configuration\n","href":"\/docs\/core\/string"},{"id":"support","title":"Support","category":"developers","intro":null,"stage":"drafting","enabled":true,"sort":9,"body":"Introduction\nStreams Core expands upon Laravel support utilities. These features both provide internal functionalities and can be easily integrated into your own work.\nLaravel Support\nArrays\nThe following methods have been added to Laravel's array helper.\nuse Illuminate\\Support\\Arr;\n\nArr::make($target);\n\nArr::make()\nConvert the target recusively to array values. This method leverages toArray and public propertis of objects to resolve arrays as well.\nArr::make($target);\nArr::make($collection);\n\nArr::parse()\nRecusively parse an array of target values. This method leverages Arr::make() to ensure an array target.\nArr::parse($target, $entry);\nArr::make($target, ['entry' =&gt; $entry]);\n\nArr::undot()\nConverts array keys with dots to nested key values. This is the opposite of Laravel's Arr::dot() method.\n$dotted = [\n    'foo.bar' =&gt; 'baz'\n];\n\n$undotted = Arr::undot($dotted);\n\narray:1 [\n  &quot;foo&quot; =&gt; array:1 [\n    &quot;bar&quot; =&gt; &quot;baz&quot;\n  ]\n]\n\nStrings\nThe following methods have been added to Laravel's string helper.\nuse Illuminate\\Support\\Str;\n\nStr::humanize($value);\n\nStr::parse()\nThe parse method parses the target string with the payload array using a dot notation.\n$payload = [\n    'foo' =&gt; [\n        'bar' =&gt; 'baz',\n    ],\n];\n\n\/\/ Example: baz\nStr::parse('Example {foo.bar}', $payload);\n\n\/\/ Hi Ryan\nStr::parse('Hi {name}', $entry);\n\nStr::purify()\nVigurously cleanse the target value of any impure content or malicious intent.\n$clean = Str::purify($dirty);\n\nStr::humanize()\nHumanize a string slug. This method returns all lowercase.\n$segment = 'streams-platform_v2';\n\n\/\/ streams platform v2\n$title = Str::humanize($segment);\n\n\/\/ Streams Platform V2\necho ucwords($title);\n\nStr::markdown()\nParse a markdown string using the fantastic Parsedown package. You\n$markdown = '#Hello';\n\n\/\/ &lt;h1&gt;Hello&lt;\/h1&gt;\necho Str::markdown($markdown);\n\nStr::linkify()\nWrap all URLs within target with links.\n$urls = 'Example: https:\/\/streams.dev\/docs';\n\n\/\/ Example: &lt;a href=&quot;https:\/\/streams.dev\/docs&quot;&gt;https:\/\/streams.dev\/docs&lt;\/a&gt;\necho Str::linkify($urls);\n\nStr::truncate()\nTruncate a string value to a given length. A third end argument maybe be used to specify the string ending which defaults to &quot;...&quot;.\n$lengthy = 'My long winded introduction has to start with my childhood.';\n\n\/\/ My long winded intro...\necho Str::truncate($lengthy, 20);\n\nStreams Support\n","href":"\/docs\/core\/support"},{"id":"time","title":"Time Type","link_title":"Time","intro":"Store time values.","category":"field_types","stage":"drafting","enabled":true,"body":"Overview\nThe time field type stores only time.\n\/\/ streams\/example.json\n&quot;fields&quot;: {\n    &quot;starts_at&quot;: {\n        &quot;type&quot;: &quot;time&quot;\n    }\n}\n\nConfiguration\n@todo Generate config options from class::configuration\nData Structure\n{\n    &quot;starts_at&quot;: &quot;09:30:00&quot;\n}\n\nBasic value access returns the stored value:\n\/\/ Basic access\n{{ $entry-&gt;starts_at }}\n\nDecorator Usage\nDate types also provide decorated values which returns a Carbon instance.\n\/\/ Decorated value\n{{ $entry-&gt;startsAt()-&gt;format('g:i a') }}\n\nMethods\n@todo Generate methods from @docs\n","href":"\/docs\/core\/time"},{"id":"url","title":"URL Type","link_title":"URL","intro":"Store URL strings.","category":"field_types","stage":"drafting","enabled":true,"body":"Overview\nThe url field type stores a url string.\n\/\/ streams\/example.json\n&quot;fields&quot;: {\n    &quot;website&quot;: {\n        &quot;type&quot;: &quot;url&quot;\n    }\n}\n\nData Structure\n{\n    &quot;website&quot;: &quot;https:\/\/website.com&quot;\n}\n\nBasic value access displays the stored value:\n\/\/ Basic access\n{{ $entry-&gt;website }}\n\nDecorator Usage\nStrings also provide decorated values.\n\/\/ Decorated value\n@if ($entry-&gt;website)\n    {!! $entry-&gt;website()-&gt;to('Visit Website') !!}\n@endif\n\nMethods\n@todo Generate methods from @docs\nConfiguration\n@todo Generate config options from class::configuration\n","href":"\/docs\/core\/url"},{"id":"validation","title":"Validation","category":"database","intro":"Organizing and executing data validation rules.","stage":"outlining","enabled":true,"sort":11,"references":["https:\/\/laravel.com\/docs\/validation"],"body":"Introduction\nThe Streams platform provides a simple interface to leverage Laravel's own validation. Please make sure you are familiar with basic Laravel validation before proceeding.\nDefining Rules\nThe Streams platform leans heavily on native Laravel validation, streamlines the process, and allows flexibility to adjust this behavior entirely.\nRule Configuration\nAll Streams rule configurations are defined as an array of rules on the field in which they apply to.\nDefining Rules\nYou may define rules whithin the field configuration:\n\/\/ streams\/contacts.json\n{\n    &quot;fields&quot;: {\n        &quot;name&quot;: {\n            &quot;type&quot;: &quot;string&quot;,\n            &quot;rules&quot;: [&quot;required&quot;, &quot;max:100&quot;]\n        },\n        &quot;email&quot;: {\n            &quot;type&quot;: &quot;email&quot;,\n            &quot;rules&quot;: [&quot;unique&quot;, &quot;required&quot;]\n        },\n        &quot;company&quot;: {\n            &quot;type&quot;: &quot;relationship&quot;,\n            &quot;config&quot;: {\n                &quot;related&quot;: &quot;companies&quot;\n            },\n            &quot;rules&quot;: [&quot;required&quot;]\n        }\n    }\n}\n\nCustom Rules\nYou may also define custom validation rules for fields.\n\/\/ streams\/contacts.json\n{\n    &quot;fields&quot;: {\n        &quot;name&quot;: {\n            &quot;type&quot;: &quot;string&quot;,\n            &quot;rules&quot;: [\n                &quot;required&quot;,\n                &quot;App\\\\Rules\\\\Example&quot;\n            ]\n        }\n    }\n}\n\nValidating\nBeing that data validation is a fundamental principle, all validation typically operates around the domain objects.\nEntry Validator\nYou can return a pre-loaded validator instance directly from the entry itself.\nuse Streams\\Core\\Support\\Facades\\Streams;\n\n$entry = Streams::repository('contacts')-&gt;find('john-doe');\n\nif ($entry-&gt;validator()-&gt;passes()) {\n    \/\/ Yay!\n}\n\nStream Validator\nYou may also return a validator instance with your own data which can be an entry object or array of data to validate as an entry.\nuse Streams\\Core\\Support\\Facades\\Streams;\n\n$validator = Streams::repository('contacts')-&gt;validator([\n    'name' =&gt; 'John Doe',\n    'email' =&gt; 'john@doe.me',\n    'company' =&gt; 'streams',\n]);\n\nif ($entry-&gt;validator()-&gt;passes()) {\n    \/\/ Yay!\n}\n\n","href":"\/docs\/core\/validation"},{"id":"views","title":"Views","intro":null,"category":"frontend","enabled":true,"stage":"reviewing","sort":0,"body":"Views contain the HTML served by the frontend of your application. You can find and define views in the resources\/views directory. A simple view might look something like this:\n\/\/ resources\/views\/welcome.blade.php\n&lt;html&gt;\n    &lt;body&gt;\n        &lt;h1&gt;{{ config('app.name') }}&lt;\/h1&gt;\n    &lt;\/body&gt;\n&lt;\/html&gt;\n\nEach file inside your resources\/views directory is a view and is available for use however you like.\nLayouts\nLayouts are the outer structural foundation of your application's HTML. It is considered best practice to leverage layouts via view inheritance to abstract your view presentation.\n\/\/ resources\/views\/layouts\/default.blade.php\n&lt;html&gt;\n    &lt;head&gt;\n        &lt;title&gt;App Name - @yield('title')&lt;\/title&gt;\n    &lt;\/head&gt;\n    &lt;body&gt;\n        @section('sidebar')\n            This is the default sidebar.\n        @show\n\n        &lt;div class=&quot;container&quot;&gt;\n            @yield('content')\n        &lt;\/div&gt;\n    &lt;\/body&gt;\n&lt;\/html&gt;\n\nExtending Layouts\nWhen defining a child view, use the Blade @extends directive to specify which layout the view should &quot;inherit&quot;. Views that extend a Blade layout may inject content into the layout's sections using @section directives. Remember, as seen in the example above, these sections' contents will be displayed in the layout using @yield:\n\/\/ resources\/views\/example.blade.php\n@extends('layouts.default')\n\n@section('title', 'Example Title')\n\n@section('sidebar')\n    @parent\n\n    &lt;p&gt;This is appended to the default sidebar.&lt;\/p&gt;\n@endsection\n\n@section('content')\n    &lt;p&gt;This is the content.&lt;\/p&gt;\n@endsection\n\nPartials\nPartials are reusable views intended to be included in many other views and even within other partials. You can use any view as a &quot;partial&quot; by using the include directive.\n\/\/ Import \/resources\/views\/partials\/assets.blade.php\n@include('partials.assets')\n\nIncludes\nIncludes are like named slots that can be accessed outside of, and prior to, the view layer.\nuse Streams\\Core\\Support\\Facades\\Includes;\n\nIncludes::include('assets', 'partials.scripts');\n\n@foreach($includes-&gt;get('assets', []) as $include)\n    @include $include\n@endforeach\n\nConventions\nWe recommend the following conventions as best practice.\nNaming\n\nUse lowercase filenames.\nUse hyphens to separate words.\nMind plurality - we can leverage this.\n\nOrganizing\nBelow is an excellent example of organizing utilitarian views like layouts and partials. These views are used for application structure and DRY'ing up views.\nresources\/views\/\n|-- partials\/\n|   |-- head.blade.php\n|   |-- footer.blade.php\n|   |-- navigation.blade.php\n|-- layouts\/\n|   |-- amp.blade.php\n|   |-- default.blade.php\n|   |-- alternate.blade.php\n\nStream Views\nOrganizing stream views by stream can not only be automatically detected but bring order to large applications. You can even bundle stream specific partials and layouts within the stream directories to separate them from similar type views intended for global use, as shown above.\nresources\/views\/\n|-- contacts\/\n|   |-- index.blade.php\n|   |-- view.blade.php\n|   |-- vcard.blade.php\n\nThe above views correlate to the below routing example.\n\/\/ streams\/contacts.json\n{\n    &quot;routes&quot;: {\n        &quot;index&quot;: &quot;contacts&quot;,\n        &quot;view&quot;: &quot;contacts\/{id}&quot;,\n        &quot;vcard&quot;: &quot;contacts\/vcard\/{id}&quot;\n    }\n}\n\n","href":"\/docs\/core\/views"}]